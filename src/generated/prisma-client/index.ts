// Code generated by Prisma (prisma@1.34.3). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export type Maybe<T> = T | undefined | null;

export interface Exists {
  build: (where?: BuildWhereInput) => Promise<boolean>;
  location: (where?: LocationWhereInput) => Promise<boolean>;
  modification: (where?: ModificationWhereInput) => Promise<boolean>;
  mundus: (where?: MundusWhereInput) => Promise<boolean>;
  post: (where?: PostWhereInput) => Promise<boolean>;
  set: (where?: SetWhereInput) => Promise<boolean>;
  setSelection: (where?: SetSelectionWhereInput) => Promise<boolean>;
  skill: (where?: SkillWhereInput) => Promise<boolean>;
  skillSelection: (where?: SkillSelectionWhereInput) => Promise<boolean>;
  specialBuff: (where?: SpecialBuffWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  build: (where: BuildWhereUniqueInput) => BuildNullablePromise;
  builds: (args?: {
    where?: BuildWhereInput;
    orderBy?: BuildOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Build>;
  buildsConnection: (args?: {
    where?: BuildWhereInput;
    orderBy?: BuildOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => BuildConnectionPromise;
  location: (where: LocationWhereUniqueInput) => LocationNullablePromise;
  locations: (args?: {
    where?: LocationWhereInput;
    orderBy?: LocationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Location>;
  locationsConnection: (args?: {
    where?: LocationWhereInput;
    orderBy?: LocationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => LocationConnectionPromise;
  modification: (
    where: ModificationWhereUniqueInput
  ) => ModificationNullablePromise;
  modifications: (args?: {
    where?: ModificationWhereInput;
    orderBy?: ModificationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Modification>;
  modificationsConnection: (args?: {
    where?: ModificationWhereInput;
    orderBy?: ModificationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ModificationConnectionPromise;
  mundus: (where: MundusWhereUniqueInput) => MundusNullablePromise;
  munduses: (args?: {
    where?: MundusWhereInput;
    orderBy?: MundusOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Mundus>;
  mundusesConnection: (args?: {
    where?: MundusWhereInput;
    orderBy?: MundusOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => MundusConnectionPromise;
  post: (where: PostWhereUniqueInput) => PostNullablePromise;
  posts: (args?: {
    where?: PostWhereInput;
    orderBy?: PostOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Post>;
  postsConnection: (args?: {
    where?: PostWhereInput;
    orderBy?: PostOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => PostConnectionPromise;
  set: (where: SetWhereUniqueInput) => SetNullablePromise;
  sets: (args?: {
    where?: SetWhereInput;
    orderBy?: SetOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Set>;
  setsConnection: (args?: {
    where?: SetWhereInput;
    orderBy?: SetOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => SetConnectionPromise;
  setSelection: (
    where: SetSelectionWhereUniqueInput
  ) => SetSelectionNullablePromise;
  setSelections: (args?: {
    where?: SetSelectionWhereInput;
    orderBy?: SetSelectionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<SetSelection>;
  setSelectionsConnection: (args?: {
    where?: SetSelectionWhereInput;
    orderBy?: SetSelectionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => SetSelectionConnectionPromise;
  skill: (where: SkillWhereUniqueInput) => SkillNullablePromise;
  skills: (args?: {
    where?: SkillWhereInput;
    orderBy?: SkillOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Skill>;
  skillsConnection: (args?: {
    where?: SkillWhereInput;
    orderBy?: SkillOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => SkillConnectionPromise;
  skillSelection: (
    where: SkillSelectionWhereUniqueInput
  ) => SkillSelectionNullablePromise;
  skillSelections: (args?: {
    where?: SkillSelectionWhereInput;
    orderBy?: SkillSelectionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<SkillSelection>;
  skillSelectionsConnection: (args?: {
    where?: SkillSelectionWhereInput;
    orderBy?: SkillSelectionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => SkillSelectionConnectionPromise;
  specialBuff: (
    where: SpecialBuffWhereUniqueInput
  ) => SpecialBuffNullablePromise;
  specialBuffs: (args?: {
    where?: SpecialBuffWhereInput;
    orderBy?: SpecialBuffOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<SpecialBuff>;
  specialBuffsConnection: (args?: {
    where?: SpecialBuffWhereInput;
    orderBy?: SpecialBuffOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => SpecialBuffConnectionPromise;
  user: (where: UserWhereUniqueInput) => UserNullablePromise;
  users: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<User>;
  usersConnection: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => UserConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createBuild: (data: BuildCreateInput) => BuildPromise;
  updateBuild: (args: {
    data: BuildUpdateInput;
    where: BuildWhereUniqueInput;
  }) => BuildPromise;
  updateManyBuilds: (args: {
    data: BuildUpdateManyMutationInput;
    where?: BuildWhereInput;
  }) => BatchPayloadPromise;
  upsertBuild: (args: {
    where: BuildWhereUniqueInput;
    create: BuildCreateInput;
    update: BuildUpdateInput;
  }) => BuildPromise;
  deleteBuild: (where: BuildWhereUniqueInput) => BuildPromise;
  deleteManyBuilds: (where?: BuildWhereInput) => BatchPayloadPromise;
  createLocation: (data: LocationCreateInput) => LocationPromise;
  updateLocation: (args: {
    data: LocationUpdateInput;
    where: LocationWhereUniqueInput;
  }) => LocationPromise;
  updateManyLocations: (args: {
    data: LocationUpdateManyMutationInput;
    where?: LocationWhereInput;
  }) => BatchPayloadPromise;
  upsertLocation: (args: {
    where: LocationWhereUniqueInput;
    create: LocationCreateInput;
    update: LocationUpdateInput;
  }) => LocationPromise;
  deleteLocation: (where: LocationWhereUniqueInput) => LocationPromise;
  deleteManyLocations: (where?: LocationWhereInput) => BatchPayloadPromise;
  createModification: (data: ModificationCreateInput) => ModificationPromise;
  updateModification: (args: {
    data: ModificationUpdateInput;
    where: ModificationWhereUniqueInput;
  }) => ModificationPromise;
  updateManyModifications: (args: {
    data: ModificationUpdateManyMutationInput;
    where?: ModificationWhereInput;
  }) => BatchPayloadPromise;
  upsertModification: (args: {
    where: ModificationWhereUniqueInput;
    create: ModificationCreateInput;
    update: ModificationUpdateInput;
  }) => ModificationPromise;
  deleteModification: (
    where: ModificationWhereUniqueInput
  ) => ModificationPromise;
  deleteManyModifications: (
    where?: ModificationWhereInput
  ) => BatchPayloadPromise;
  createMundus: (data: MundusCreateInput) => MundusPromise;
  updateMundus: (args: {
    data: MundusUpdateInput;
    where: MundusWhereUniqueInput;
  }) => MundusPromise;
  updateManyMunduses: (args: {
    data: MundusUpdateManyMutationInput;
    where?: MundusWhereInput;
  }) => BatchPayloadPromise;
  upsertMundus: (args: {
    where: MundusWhereUniqueInput;
    create: MundusCreateInput;
    update: MundusUpdateInput;
  }) => MundusPromise;
  deleteMundus: (where: MundusWhereUniqueInput) => MundusPromise;
  deleteManyMunduses: (where?: MundusWhereInput) => BatchPayloadPromise;
  createPost: (data: PostCreateInput) => PostPromise;
  updatePost: (args: {
    data: PostUpdateInput;
    where: PostWhereUniqueInput;
  }) => PostPromise;
  updateManyPosts: (args: {
    data: PostUpdateManyMutationInput;
    where?: PostWhereInput;
  }) => BatchPayloadPromise;
  upsertPost: (args: {
    where: PostWhereUniqueInput;
    create: PostCreateInput;
    update: PostUpdateInput;
  }) => PostPromise;
  deletePost: (where: PostWhereUniqueInput) => PostPromise;
  deleteManyPosts: (where?: PostWhereInput) => BatchPayloadPromise;
  createSet: (data: SetCreateInput) => SetPromise;
  updateSet: (args: {
    data: SetUpdateInput;
    where: SetWhereUniqueInput;
  }) => SetPromise;
  updateManySets: (args: {
    data: SetUpdateManyMutationInput;
    where?: SetWhereInput;
  }) => BatchPayloadPromise;
  upsertSet: (args: {
    where: SetWhereUniqueInput;
    create: SetCreateInput;
    update: SetUpdateInput;
  }) => SetPromise;
  deleteSet: (where: SetWhereUniqueInput) => SetPromise;
  deleteManySets: (where?: SetWhereInput) => BatchPayloadPromise;
  createSetSelection: (data: SetSelectionCreateInput) => SetSelectionPromise;
  updateSetSelection: (args: {
    data: SetSelectionUpdateInput;
    where: SetSelectionWhereUniqueInput;
  }) => SetSelectionPromise;
  updateManySetSelections: (args: {
    data: SetSelectionUpdateManyMutationInput;
    where?: SetSelectionWhereInput;
  }) => BatchPayloadPromise;
  upsertSetSelection: (args: {
    where: SetSelectionWhereUniqueInput;
    create: SetSelectionCreateInput;
    update: SetSelectionUpdateInput;
  }) => SetSelectionPromise;
  deleteSetSelection: (
    where: SetSelectionWhereUniqueInput
  ) => SetSelectionPromise;
  deleteManySetSelections: (
    where?: SetSelectionWhereInput
  ) => BatchPayloadPromise;
  createSkill: (data: SkillCreateInput) => SkillPromise;
  updateSkill: (args: {
    data: SkillUpdateInput;
    where: SkillWhereUniqueInput;
  }) => SkillPromise;
  updateManySkills: (args: {
    data: SkillUpdateManyMutationInput;
    where?: SkillWhereInput;
  }) => BatchPayloadPromise;
  upsertSkill: (args: {
    where: SkillWhereUniqueInput;
    create: SkillCreateInput;
    update: SkillUpdateInput;
  }) => SkillPromise;
  deleteSkill: (where: SkillWhereUniqueInput) => SkillPromise;
  deleteManySkills: (where?: SkillWhereInput) => BatchPayloadPromise;
  createSkillSelection: (
    data: SkillSelectionCreateInput
  ) => SkillSelectionPromise;
  updateSkillSelection: (args: {
    data: SkillSelectionUpdateInput;
    where: SkillSelectionWhereUniqueInput;
  }) => SkillSelectionPromise;
  updateManySkillSelections: (args: {
    data: SkillSelectionUpdateManyMutationInput;
    where?: SkillSelectionWhereInput;
  }) => BatchPayloadPromise;
  upsertSkillSelection: (args: {
    where: SkillSelectionWhereUniqueInput;
    create: SkillSelectionCreateInput;
    update: SkillSelectionUpdateInput;
  }) => SkillSelectionPromise;
  deleteSkillSelection: (
    where: SkillSelectionWhereUniqueInput
  ) => SkillSelectionPromise;
  deleteManySkillSelections: (
    where?: SkillSelectionWhereInput
  ) => BatchPayloadPromise;
  createSpecialBuff: (data: SpecialBuffCreateInput) => SpecialBuffPromise;
  updateSpecialBuff: (args: {
    data: SpecialBuffUpdateInput;
    where: SpecialBuffWhereUniqueInput;
  }) => SpecialBuffPromise;
  updateManySpecialBuffs: (args: {
    data: SpecialBuffUpdateManyMutationInput;
    where?: SpecialBuffWhereInput;
  }) => BatchPayloadPromise;
  upsertSpecialBuff: (args: {
    where: SpecialBuffWhereUniqueInput;
    create: SpecialBuffCreateInput;
    update: SpecialBuffUpdateInput;
  }) => SpecialBuffPromise;
  deleteSpecialBuff: (where: SpecialBuffWhereUniqueInput) => SpecialBuffPromise;
  deleteManySpecialBuffs: (
    where?: SpecialBuffWhereInput
  ) => BatchPayloadPromise;
  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (args: {
    data: UserUpdateInput;
    where: UserWhereUniqueInput;
  }) => UserPromise;
  updateManyUsers: (args: {
    data: UserUpdateManyMutationInput;
    where?: UserWhereInput;
  }) => BatchPayloadPromise;
  upsertUser: (args: {
    where: UserWhereUniqueInput;
    create: UserCreateInput;
    update: UserUpdateInput;
  }) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  build: (
    where?: BuildSubscriptionWhereInput
  ) => BuildSubscriptionPayloadSubscription;
  location: (
    where?: LocationSubscriptionWhereInput
  ) => LocationSubscriptionPayloadSubscription;
  modification: (
    where?: ModificationSubscriptionWhereInput
  ) => ModificationSubscriptionPayloadSubscription;
  mundus: (
    where?: MundusSubscriptionWhereInput
  ) => MundusSubscriptionPayloadSubscription;
  post: (
    where?: PostSubscriptionWhereInput
  ) => PostSubscriptionPayloadSubscription;
  set: (
    where?: SetSubscriptionWhereInput
  ) => SetSubscriptionPayloadSubscription;
  setSelection: (
    where?: SetSelectionSubscriptionWhereInput
  ) => SetSelectionSubscriptionPayloadSubscription;
  skill: (
    where?: SkillSubscriptionWhereInput
  ) => SkillSubscriptionPayloadSubscription;
  skillSelection: (
    where?: SkillSelectionSubscriptionWhereInput
  ) => SkillSelectionSubscriptionPayloadSubscription;
  specialBuff: (
    where?: SpecialBuffSubscriptionWhereInput
  ) => SpecialBuffSubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type SetSelectionOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "icon_ASC"
  | "icon_DESC"
  | "slot_ASC"
  | "slot_DESC";

export type SkillSelectionOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "index_ASC"
  | "index_DESC";

export type BuildOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "race_ASC"
  | "race_DESC"
  | "class_ASC"
  | "class_DESC";

export type LocationOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "aldmeri_ASC"
  | "aldmeri_DESC"
  | "daggerfall_ASC"
  | "daggerfall_DESC"
  | "ebonheart_ASC"
  | "ebonheart_DESC";

export type ModificationOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "type_ASC"
  | "type_DESC"
  | "description_ASC"
  | "description_DESC"
  | "icon_ASC"
  | "icon_DESC";

export type MundusOrderByInput =
  | "name_ASC"
  | "name_DESC"
  | "effect_ASC"
  | "effect_DESC"
  | "value_ASC"
  | "value_DESC"
  | "icon_ASC"
  | "icon_DESC"
  | "id_ASC"
  | "id_DESC";

export type PostOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "published_ASC"
  | "published_DESC"
  | "title_ASC"
  | "title_DESC"
  | "content_ASC"
  | "content_DESC";

export type SetOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "setId_ASC"
  | "setId_DESC"
  | "name_ASC"
  | "name_DESC"
  | "location_ASC"
  | "location_DESC"
  | "type_ASC"
  | "type_DESC"
  | "slug_ASC"
  | "slug_DESC"
  | "bonus_item_1_ASC"
  | "bonus_item_1_DESC"
  | "bonus_item_2_ASC"
  | "bonus_item_2_DESC"
  | "bonus_item_3_ASC"
  | "bonus_item_3_DESC"
  | "bonus_item_4_ASC"
  | "bonus_item_4_DESC"
  | "bonus_item_5_ASC"
  | "bonus_item_5_DESC"
  | "has_jewels_ASC"
  | "has_jewels_DESC"
  | "has_weapons_ASC"
  | "has_weapons_DESC"
  | "has_heavy_armor_ASC"
  | "has_heavy_armor_DESC"
  | "has_light_armor_ASC"
  | "has_light_armor_DESC"
  | "has_medium_armor_ASC"
  | "has_medium_armor_DESC"
  | "traits_needed_ASC"
  | "traits_needed_DESC"
  | "pts_ASC"
  | "pts_DESC"
  | "eso_id_ASC"
  | "eso_id_DESC";

export type SkillOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "skillId_ASC"
  | "skillId_DESC"
  | "cast_time_ASC"
  | "cast_time_DESC"
  | "cost_ASC"
  | "cost_DESC"
  | "effect_1_ASC"
  | "effect_1_DESC"
  | "effect_2_ASC"
  | "effect_2_DESC"
  | "icon_ASC"
  | "icon_DESC"
  | "name_ASC"
  | "name_DESC"
  | "parent_ASC"
  | "parent_DESC"
  | "pts_ASC"
  | "pts_DESC"
  | "range_ASC"
  | "range_DESC"
  | "skillline_ASC"
  | "skillline_DESC"
  | "slug_ASC"
  | "slug_DESC"
  | "target_ASC"
  | "target_DESC"
  | "type_ASC"
  | "type_DESC"
  | "unlocks_at_ASC"
  | "unlocks_at_DESC";

export type SpecialBuffOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "buffDescription_ASC"
  | "buffDescription_DESC"
  | "description_ASC"
  | "description_DESC"
  | "duration_ASC"
  | "duration_DESC"
  | "notes_ASC"
  | "notes_DESC"
  | "icon_ASC"
  | "icon_DESC"
  | "type_ASC"
  | "type_DESC"
  | "quality_ASC"
  | "quality_DESC";

export type UserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "email_ASC"
  | "email_DESC"
  | "password_ASC"
  | "password_DESC"
  | "name_ASC"
  | "name_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type BuildWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface SetSelectionWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  icon?: Maybe<String>;
  icon_not?: Maybe<String>;
  icon_in?: Maybe<String[] | String>;
  icon_not_in?: Maybe<String[] | String>;
  icon_lt?: Maybe<String>;
  icon_lte?: Maybe<String>;
  icon_gt?: Maybe<String>;
  icon_gte?: Maybe<String>;
  icon_contains?: Maybe<String>;
  icon_not_contains?: Maybe<String>;
  icon_starts_with?: Maybe<String>;
  icon_not_starts_with?: Maybe<String>;
  icon_ends_with?: Maybe<String>;
  icon_not_ends_with?: Maybe<String>;
  slot?: Maybe<String>;
  slot_not?: Maybe<String>;
  slot_in?: Maybe<String[] | String>;
  slot_not_in?: Maybe<String[] | String>;
  slot_lt?: Maybe<String>;
  slot_lte?: Maybe<String>;
  slot_gt?: Maybe<String>;
  slot_gte?: Maybe<String>;
  slot_contains?: Maybe<String>;
  slot_not_contains?: Maybe<String>;
  slot_starts_with?: Maybe<String>;
  slot_not_starts_with?: Maybe<String>;
  slot_ends_with?: Maybe<String>;
  slot_not_ends_with?: Maybe<String>;
  selectedSet?: Maybe<SetWhereInput>;
  trait?: Maybe<ModificationWhereInput>;
  glyph?: Maybe<ModificationWhereInput>;
  AND?: Maybe<SetSelectionWhereInput[] | SetSelectionWhereInput>;
  OR?: Maybe<SetSelectionWhereInput[] | SetSelectionWhereInput>;
  NOT?: Maybe<SetSelectionWhereInput[] | SetSelectionWhereInput>;
}

export interface SetWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  setId?: Maybe<Int>;
  setId_not?: Maybe<Int>;
  setId_in?: Maybe<Int[] | Int>;
  setId_not_in?: Maybe<Int[] | Int>;
  setId_lt?: Maybe<Int>;
  setId_lte?: Maybe<Int>;
  setId_gt?: Maybe<Int>;
  setId_gte?: Maybe<Int>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  location?: Maybe<String>;
  location_not?: Maybe<String>;
  location_in?: Maybe<String[] | String>;
  location_not_in?: Maybe<String[] | String>;
  location_lt?: Maybe<String>;
  location_lte?: Maybe<String>;
  location_gt?: Maybe<String>;
  location_gte?: Maybe<String>;
  location_contains?: Maybe<String>;
  location_not_contains?: Maybe<String>;
  location_starts_with?: Maybe<String>;
  location_not_starts_with?: Maybe<String>;
  location_ends_with?: Maybe<String>;
  location_not_ends_with?: Maybe<String>;
  type?: Maybe<String>;
  type_not?: Maybe<String>;
  type_in?: Maybe<String[] | String>;
  type_not_in?: Maybe<String[] | String>;
  type_lt?: Maybe<String>;
  type_lte?: Maybe<String>;
  type_gt?: Maybe<String>;
  type_gte?: Maybe<String>;
  type_contains?: Maybe<String>;
  type_not_contains?: Maybe<String>;
  type_starts_with?: Maybe<String>;
  type_not_starts_with?: Maybe<String>;
  type_ends_with?: Maybe<String>;
  type_not_ends_with?: Maybe<String>;
  slug?: Maybe<String>;
  slug_not?: Maybe<String>;
  slug_in?: Maybe<String[] | String>;
  slug_not_in?: Maybe<String[] | String>;
  slug_lt?: Maybe<String>;
  slug_lte?: Maybe<String>;
  slug_gt?: Maybe<String>;
  slug_gte?: Maybe<String>;
  slug_contains?: Maybe<String>;
  slug_not_contains?: Maybe<String>;
  slug_starts_with?: Maybe<String>;
  slug_not_starts_with?: Maybe<String>;
  slug_ends_with?: Maybe<String>;
  slug_not_ends_with?: Maybe<String>;
  bonus_item_1?: Maybe<String>;
  bonus_item_1_not?: Maybe<String>;
  bonus_item_1_in?: Maybe<String[] | String>;
  bonus_item_1_not_in?: Maybe<String[] | String>;
  bonus_item_1_lt?: Maybe<String>;
  bonus_item_1_lte?: Maybe<String>;
  bonus_item_1_gt?: Maybe<String>;
  bonus_item_1_gte?: Maybe<String>;
  bonus_item_1_contains?: Maybe<String>;
  bonus_item_1_not_contains?: Maybe<String>;
  bonus_item_1_starts_with?: Maybe<String>;
  bonus_item_1_not_starts_with?: Maybe<String>;
  bonus_item_1_ends_with?: Maybe<String>;
  bonus_item_1_not_ends_with?: Maybe<String>;
  bonus_item_2?: Maybe<String>;
  bonus_item_2_not?: Maybe<String>;
  bonus_item_2_in?: Maybe<String[] | String>;
  bonus_item_2_not_in?: Maybe<String[] | String>;
  bonus_item_2_lt?: Maybe<String>;
  bonus_item_2_lte?: Maybe<String>;
  bonus_item_2_gt?: Maybe<String>;
  bonus_item_2_gte?: Maybe<String>;
  bonus_item_2_contains?: Maybe<String>;
  bonus_item_2_not_contains?: Maybe<String>;
  bonus_item_2_starts_with?: Maybe<String>;
  bonus_item_2_not_starts_with?: Maybe<String>;
  bonus_item_2_ends_with?: Maybe<String>;
  bonus_item_2_not_ends_with?: Maybe<String>;
  bonus_item_3?: Maybe<String>;
  bonus_item_3_not?: Maybe<String>;
  bonus_item_3_in?: Maybe<String[] | String>;
  bonus_item_3_not_in?: Maybe<String[] | String>;
  bonus_item_3_lt?: Maybe<String>;
  bonus_item_3_lte?: Maybe<String>;
  bonus_item_3_gt?: Maybe<String>;
  bonus_item_3_gte?: Maybe<String>;
  bonus_item_3_contains?: Maybe<String>;
  bonus_item_3_not_contains?: Maybe<String>;
  bonus_item_3_starts_with?: Maybe<String>;
  bonus_item_3_not_starts_with?: Maybe<String>;
  bonus_item_3_ends_with?: Maybe<String>;
  bonus_item_3_not_ends_with?: Maybe<String>;
  bonus_item_4?: Maybe<String>;
  bonus_item_4_not?: Maybe<String>;
  bonus_item_4_in?: Maybe<String[] | String>;
  bonus_item_4_not_in?: Maybe<String[] | String>;
  bonus_item_4_lt?: Maybe<String>;
  bonus_item_4_lte?: Maybe<String>;
  bonus_item_4_gt?: Maybe<String>;
  bonus_item_4_gte?: Maybe<String>;
  bonus_item_4_contains?: Maybe<String>;
  bonus_item_4_not_contains?: Maybe<String>;
  bonus_item_4_starts_with?: Maybe<String>;
  bonus_item_4_not_starts_with?: Maybe<String>;
  bonus_item_4_ends_with?: Maybe<String>;
  bonus_item_4_not_ends_with?: Maybe<String>;
  bonus_item_5?: Maybe<String>;
  bonus_item_5_not?: Maybe<String>;
  bonus_item_5_in?: Maybe<String[] | String>;
  bonus_item_5_not_in?: Maybe<String[] | String>;
  bonus_item_5_lt?: Maybe<String>;
  bonus_item_5_lte?: Maybe<String>;
  bonus_item_5_gt?: Maybe<String>;
  bonus_item_5_gte?: Maybe<String>;
  bonus_item_5_contains?: Maybe<String>;
  bonus_item_5_not_contains?: Maybe<String>;
  bonus_item_5_starts_with?: Maybe<String>;
  bonus_item_5_not_starts_with?: Maybe<String>;
  bonus_item_5_ends_with?: Maybe<String>;
  bonus_item_5_not_ends_with?: Maybe<String>;
  has_jewels?: Maybe<Int>;
  has_jewels_not?: Maybe<Int>;
  has_jewels_in?: Maybe<Int[] | Int>;
  has_jewels_not_in?: Maybe<Int[] | Int>;
  has_jewels_lt?: Maybe<Int>;
  has_jewels_lte?: Maybe<Int>;
  has_jewels_gt?: Maybe<Int>;
  has_jewels_gte?: Maybe<Int>;
  has_weapons?: Maybe<Int>;
  has_weapons_not?: Maybe<Int>;
  has_weapons_in?: Maybe<Int[] | Int>;
  has_weapons_not_in?: Maybe<Int[] | Int>;
  has_weapons_lt?: Maybe<Int>;
  has_weapons_lte?: Maybe<Int>;
  has_weapons_gt?: Maybe<Int>;
  has_weapons_gte?: Maybe<Int>;
  has_heavy_armor?: Maybe<Int>;
  has_heavy_armor_not?: Maybe<Int>;
  has_heavy_armor_in?: Maybe<Int[] | Int>;
  has_heavy_armor_not_in?: Maybe<Int[] | Int>;
  has_heavy_armor_lt?: Maybe<Int>;
  has_heavy_armor_lte?: Maybe<Int>;
  has_heavy_armor_gt?: Maybe<Int>;
  has_heavy_armor_gte?: Maybe<Int>;
  has_light_armor?: Maybe<Int>;
  has_light_armor_not?: Maybe<Int>;
  has_light_armor_in?: Maybe<Int[] | Int>;
  has_light_armor_not_in?: Maybe<Int[] | Int>;
  has_light_armor_lt?: Maybe<Int>;
  has_light_armor_lte?: Maybe<Int>;
  has_light_armor_gt?: Maybe<Int>;
  has_light_armor_gte?: Maybe<Int>;
  has_medium_armor?: Maybe<Int>;
  has_medium_armor_not?: Maybe<Int>;
  has_medium_armor_in?: Maybe<Int[] | Int>;
  has_medium_armor_not_in?: Maybe<Int[] | Int>;
  has_medium_armor_lt?: Maybe<Int>;
  has_medium_armor_lte?: Maybe<Int>;
  has_medium_armor_gt?: Maybe<Int>;
  has_medium_armor_gte?: Maybe<Int>;
  traits_needed?: Maybe<Int>;
  traits_needed_not?: Maybe<Int>;
  traits_needed_in?: Maybe<Int[] | Int>;
  traits_needed_not_in?: Maybe<Int[] | Int>;
  traits_needed_lt?: Maybe<Int>;
  traits_needed_lte?: Maybe<Int>;
  traits_needed_gt?: Maybe<Int>;
  traits_needed_gte?: Maybe<Int>;
  pts?: Maybe<Int>;
  pts_not?: Maybe<Int>;
  pts_in?: Maybe<Int[] | Int>;
  pts_not_in?: Maybe<Int[] | Int>;
  pts_lt?: Maybe<Int>;
  pts_lte?: Maybe<Int>;
  pts_gt?: Maybe<Int>;
  pts_gte?: Maybe<Int>;
  eso_id?: Maybe<Int>;
  eso_id_not?: Maybe<Int>;
  eso_id_in?: Maybe<Int[] | Int>;
  eso_id_not_in?: Maybe<Int[] | Int>;
  eso_id_lt?: Maybe<Int>;
  eso_id_lte?: Maybe<Int>;
  eso_id_gt?: Maybe<Int>;
  eso_id_gte?: Maybe<Int>;
  AND?: Maybe<SetWhereInput[] | SetWhereInput>;
  OR?: Maybe<SetWhereInput[] | SetWhereInput>;
  NOT?: Maybe<SetWhereInput[] | SetWhereInput>;
}

export interface ModificationWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  type?: Maybe<String>;
  type_not?: Maybe<String>;
  type_in?: Maybe<String[] | String>;
  type_not_in?: Maybe<String[] | String>;
  type_lt?: Maybe<String>;
  type_lte?: Maybe<String>;
  type_gt?: Maybe<String>;
  type_gte?: Maybe<String>;
  type_contains?: Maybe<String>;
  type_not_contains?: Maybe<String>;
  type_starts_with?: Maybe<String>;
  type_not_starts_with?: Maybe<String>;
  type_ends_with?: Maybe<String>;
  type_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  icon?: Maybe<String>;
  icon_not?: Maybe<String>;
  icon_in?: Maybe<String[] | String>;
  icon_not_in?: Maybe<String[] | String>;
  icon_lt?: Maybe<String>;
  icon_lte?: Maybe<String>;
  icon_gt?: Maybe<String>;
  icon_gte?: Maybe<String>;
  icon_contains?: Maybe<String>;
  icon_not_contains?: Maybe<String>;
  icon_starts_with?: Maybe<String>;
  icon_not_starts_with?: Maybe<String>;
  icon_ends_with?: Maybe<String>;
  icon_not_ends_with?: Maybe<String>;
  AND?: Maybe<ModificationWhereInput[] | ModificationWhereInput>;
  OR?: Maybe<ModificationWhereInput[] | ModificationWhereInput>;
  NOT?: Maybe<ModificationWhereInput[] | ModificationWhereInput>;
}

export interface SkillSelectionWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  index?: Maybe<Int>;
  index_not?: Maybe<Int>;
  index_in?: Maybe<Int[] | Int>;
  index_not_in?: Maybe<Int[] | Int>;
  index_lt?: Maybe<Int>;
  index_lte?: Maybe<Int>;
  index_gt?: Maybe<Int>;
  index_gte?: Maybe<Int>;
  skill?: Maybe<SkillWhereInput>;
  AND?: Maybe<SkillSelectionWhereInput[] | SkillSelectionWhereInput>;
  OR?: Maybe<SkillSelectionWhereInput[] | SkillSelectionWhereInput>;
  NOT?: Maybe<SkillSelectionWhereInput[] | SkillSelectionWhereInput>;
}

export interface SkillWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  skillId?: Maybe<Int>;
  skillId_not?: Maybe<Int>;
  skillId_in?: Maybe<Int[] | Int>;
  skillId_not_in?: Maybe<Int[] | Int>;
  skillId_lt?: Maybe<Int>;
  skillId_lte?: Maybe<Int>;
  skillId_gt?: Maybe<Int>;
  skillId_gte?: Maybe<Int>;
  cast_time?: Maybe<String>;
  cast_time_not?: Maybe<String>;
  cast_time_in?: Maybe<String[] | String>;
  cast_time_not_in?: Maybe<String[] | String>;
  cast_time_lt?: Maybe<String>;
  cast_time_lte?: Maybe<String>;
  cast_time_gt?: Maybe<String>;
  cast_time_gte?: Maybe<String>;
  cast_time_contains?: Maybe<String>;
  cast_time_not_contains?: Maybe<String>;
  cast_time_starts_with?: Maybe<String>;
  cast_time_not_starts_with?: Maybe<String>;
  cast_time_ends_with?: Maybe<String>;
  cast_time_not_ends_with?: Maybe<String>;
  cost?: Maybe<String>;
  cost_not?: Maybe<String>;
  cost_in?: Maybe<String[] | String>;
  cost_not_in?: Maybe<String[] | String>;
  cost_lt?: Maybe<String>;
  cost_lte?: Maybe<String>;
  cost_gt?: Maybe<String>;
  cost_gte?: Maybe<String>;
  cost_contains?: Maybe<String>;
  cost_not_contains?: Maybe<String>;
  cost_starts_with?: Maybe<String>;
  cost_not_starts_with?: Maybe<String>;
  cost_ends_with?: Maybe<String>;
  cost_not_ends_with?: Maybe<String>;
  effect_1?: Maybe<String>;
  effect_1_not?: Maybe<String>;
  effect_1_in?: Maybe<String[] | String>;
  effect_1_not_in?: Maybe<String[] | String>;
  effect_1_lt?: Maybe<String>;
  effect_1_lte?: Maybe<String>;
  effect_1_gt?: Maybe<String>;
  effect_1_gte?: Maybe<String>;
  effect_1_contains?: Maybe<String>;
  effect_1_not_contains?: Maybe<String>;
  effect_1_starts_with?: Maybe<String>;
  effect_1_not_starts_with?: Maybe<String>;
  effect_1_ends_with?: Maybe<String>;
  effect_1_not_ends_with?: Maybe<String>;
  effect_2?: Maybe<String>;
  effect_2_not?: Maybe<String>;
  effect_2_in?: Maybe<String[] | String>;
  effect_2_not_in?: Maybe<String[] | String>;
  effect_2_lt?: Maybe<String>;
  effect_2_lte?: Maybe<String>;
  effect_2_gt?: Maybe<String>;
  effect_2_gte?: Maybe<String>;
  effect_2_contains?: Maybe<String>;
  effect_2_not_contains?: Maybe<String>;
  effect_2_starts_with?: Maybe<String>;
  effect_2_not_starts_with?: Maybe<String>;
  effect_2_ends_with?: Maybe<String>;
  effect_2_not_ends_with?: Maybe<String>;
  icon?: Maybe<String>;
  icon_not?: Maybe<String>;
  icon_in?: Maybe<String[] | String>;
  icon_not_in?: Maybe<String[] | String>;
  icon_lt?: Maybe<String>;
  icon_lte?: Maybe<String>;
  icon_gt?: Maybe<String>;
  icon_gte?: Maybe<String>;
  icon_contains?: Maybe<String>;
  icon_not_contains?: Maybe<String>;
  icon_starts_with?: Maybe<String>;
  icon_not_starts_with?: Maybe<String>;
  icon_ends_with?: Maybe<String>;
  icon_not_ends_with?: Maybe<String>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  parent?: Maybe<Int>;
  parent_not?: Maybe<Int>;
  parent_in?: Maybe<Int[] | Int>;
  parent_not_in?: Maybe<Int[] | Int>;
  parent_lt?: Maybe<Int>;
  parent_lte?: Maybe<Int>;
  parent_gt?: Maybe<Int>;
  parent_gte?: Maybe<Int>;
  pts?: Maybe<Int>;
  pts_not?: Maybe<Int>;
  pts_in?: Maybe<Int[] | Int>;
  pts_not_in?: Maybe<Int[] | Int>;
  pts_lt?: Maybe<Int>;
  pts_lte?: Maybe<Int>;
  pts_gt?: Maybe<Int>;
  pts_gte?: Maybe<Int>;
  range?: Maybe<String>;
  range_not?: Maybe<String>;
  range_in?: Maybe<String[] | String>;
  range_not_in?: Maybe<String[] | String>;
  range_lt?: Maybe<String>;
  range_lte?: Maybe<String>;
  range_gt?: Maybe<String>;
  range_gte?: Maybe<String>;
  range_contains?: Maybe<String>;
  range_not_contains?: Maybe<String>;
  range_starts_with?: Maybe<String>;
  range_not_starts_with?: Maybe<String>;
  range_ends_with?: Maybe<String>;
  range_not_ends_with?: Maybe<String>;
  skillline?: Maybe<Int>;
  skillline_not?: Maybe<Int>;
  skillline_in?: Maybe<Int[] | Int>;
  skillline_not_in?: Maybe<Int[] | Int>;
  skillline_lt?: Maybe<Int>;
  skillline_lte?: Maybe<Int>;
  skillline_gt?: Maybe<Int>;
  skillline_gte?: Maybe<Int>;
  slug?: Maybe<String>;
  slug_not?: Maybe<String>;
  slug_in?: Maybe<String[] | String>;
  slug_not_in?: Maybe<String[] | String>;
  slug_lt?: Maybe<String>;
  slug_lte?: Maybe<String>;
  slug_gt?: Maybe<String>;
  slug_gte?: Maybe<String>;
  slug_contains?: Maybe<String>;
  slug_not_contains?: Maybe<String>;
  slug_starts_with?: Maybe<String>;
  slug_not_starts_with?: Maybe<String>;
  slug_ends_with?: Maybe<String>;
  slug_not_ends_with?: Maybe<String>;
  target?: Maybe<String>;
  target_not?: Maybe<String>;
  target_in?: Maybe<String[] | String>;
  target_not_in?: Maybe<String[] | String>;
  target_lt?: Maybe<String>;
  target_lte?: Maybe<String>;
  target_gt?: Maybe<String>;
  target_gte?: Maybe<String>;
  target_contains?: Maybe<String>;
  target_not_contains?: Maybe<String>;
  target_starts_with?: Maybe<String>;
  target_not_starts_with?: Maybe<String>;
  target_ends_with?: Maybe<String>;
  target_not_ends_with?: Maybe<String>;
  type?: Maybe<Int>;
  type_not?: Maybe<Int>;
  type_in?: Maybe<Int[] | Int>;
  type_not_in?: Maybe<Int[] | Int>;
  type_lt?: Maybe<Int>;
  type_lte?: Maybe<Int>;
  type_gt?: Maybe<Int>;
  type_gte?: Maybe<Int>;
  unlocks_at?: Maybe<Int>;
  unlocks_at_not?: Maybe<Int>;
  unlocks_at_in?: Maybe<Int[] | Int>;
  unlocks_at_not_in?: Maybe<Int[] | Int>;
  unlocks_at_lt?: Maybe<Int>;
  unlocks_at_lte?: Maybe<Int>;
  unlocks_at_gt?: Maybe<Int>;
  unlocks_at_gte?: Maybe<Int>;
  AND?: Maybe<SkillWhereInput[] | SkillWhereInput>;
  OR?: Maybe<SkillWhereInput[] | SkillWhereInput>;
  NOT?: Maybe<SkillWhereInput[] | SkillWhereInput>;
}

export interface BuildWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  race?: Maybe<String>;
  race_not?: Maybe<String>;
  race_in?: Maybe<String[] | String>;
  race_not_in?: Maybe<String[] | String>;
  race_lt?: Maybe<String>;
  race_lte?: Maybe<String>;
  race_gt?: Maybe<String>;
  race_gte?: Maybe<String>;
  race_contains?: Maybe<String>;
  race_not_contains?: Maybe<String>;
  race_starts_with?: Maybe<String>;
  race_not_starts_with?: Maybe<String>;
  race_ends_with?: Maybe<String>;
  race_not_ends_with?: Maybe<String>;
  class?: Maybe<String>;
  class_not?: Maybe<String>;
  class_in?: Maybe<String[] | String>;
  class_not_in?: Maybe<String[] | String>;
  class_lt?: Maybe<String>;
  class_lte?: Maybe<String>;
  class_gt?: Maybe<String>;
  class_gte?: Maybe<String>;
  class_contains?: Maybe<String>;
  class_not_contains?: Maybe<String>;
  class_starts_with?: Maybe<String>;
  class_not_starts_with?: Maybe<String>;
  class_ends_with?: Maybe<String>;
  class_not_ends_with?: Maybe<String>;
  bigPieceSelection_every?: Maybe<SetSelectionWhereInput>;
  bigPieceSelection_some?: Maybe<SetSelectionWhereInput>;
  bigPieceSelection_none?: Maybe<SetSelectionWhereInput>;
  smallPieceSelection_every?: Maybe<SetSelectionWhereInput>;
  smallPieceSelection_some?: Maybe<SetSelectionWhereInput>;
  smallPieceSelection_none?: Maybe<SetSelectionWhereInput>;
  jewelrySelection_every?: Maybe<SetSelectionWhereInput>;
  jewelrySelection_some?: Maybe<SetSelectionWhereInput>;
  jewelrySelection_none?: Maybe<SetSelectionWhereInput>;
  frontbarSelection_every?: Maybe<SetSelectionWhereInput>;
  frontbarSelection_some?: Maybe<SetSelectionWhereInput>;
  frontbarSelection_none?: Maybe<SetSelectionWhereInput>;
  backbarSelection_every?: Maybe<SetSelectionWhereInput>;
  backbarSelection_some?: Maybe<SetSelectionWhereInput>;
  backbarSelection_none?: Maybe<SetSelectionWhereInput>;
  newBarOne_every?: Maybe<SkillSelectionWhereInput>;
  newBarOne_some?: Maybe<SkillSelectionWhereInput>;
  newBarOne_none?: Maybe<SkillSelectionWhereInput>;
  newBarTwo_every?: Maybe<SkillSelectionWhereInput>;
  newBarTwo_some?: Maybe<SkillSelectionWhereInput>;
  newBarTwo_none?: Maybe<SkillSelectionWhereInput>;
  ultimateOne?: Maybe<SkillWhereInput>;
  ultimateTwo?: Maybe<SkillWhereInput>;
  mundus?: Maybe<MundusWhereInput>;
  buff?: Maybe<SpecialBuffWhereInput>;
  AND?: Maybe<BuildWhereInput[] | BuildWhereInput>;
  OR?: Maybe<BuildWhereInput[] | BuildWhereInput>;
  NOT?: Maybe<BuildWhereInput[] | BuildWhereInput>;
}

export interface MundusWhereInput {
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  location?: Maybe<LocationWhereInput>;
  effect?: Maybe<String>;
  effect_not?: Maybe<String>;
  effect_in?: Maybe<String[] | String>;
  effect_not_in?: Maybe<String[] | String>;
  effect_lt?: Maybe<String>;
  effect_lte?: Maybe<String>;
  effect_gt?: Maybe<String>;
  effect_gte?: Maybe<String>;
  effect_contains?: Maybe<String>;
  effect_not_contains?: Maybe<String>;
  effect_starts_with?: Maybe<String>;
  effect_not_starts_with?: Maybe<String>;
  effect_ends_with?: Maybe<String>;
  effect_not_ends_with?: Maybe<String>;
  value?: Maybe<String>;
  value_not?: Maybe<String>;
  value_in?: Maybe<String[] | String>;
  value_not_in?: Maybe<String[] | String>;
  value_lt?: Maybe<String>;
  value_lte?: Maybe<String>;
  value_gt?: Maybe<String>;
  value_gte?: Maybe<String>;
  value_contains?: Maybe<String>;
  value_not_contains?: Maybe<String>;
  value_starts_with?: Maybe<String>;
  value_not_starts_with?: Maybe<String>;
  value_ends_with?: Maybe<String>;
  value_not_ends_with?: Maybe<String>;
  icon?: Maybe<String>;
  icon_not?: Maybe<String>;
  icon_in?: Maybe<String[] | String>;
  icon_not_in?: Maybe<String[] | String>;
  icon_lt?: Maybe<String>;
  icon_lte?: Maybe<String>;
  icon_gt?: Maybe<String>;
  icon_gte?: Maybe<String>;
  icon_contains?: Maybe<String>;
  icon_not_contains?: Maybe<String>;
  icon_starts_with?: Maybe<String>;
  icon_not_starts_with?: Maybe<String>;
  icon_ends_with?: Maybe<String>;
  icon_not_ends_with?: Maybe<String>;
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  AND?: Maybe<MundusWhereInput[] | MundusWhereInput>;
  OR?: Maybe<MundusWhereInput[] | MundusWhereInput>;
  NOT?: Maybe<MundusWhereInput[] | MundusWhereInput>;
}

export interface LocationWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  aldmeri?: Maybe<String>;
  aldmeri_not?: Maybe<String>;
  aldmeri_in?: Maybe<String[] | String>;
  aldmeri_not_in?: Maybe<String[] | String>;
  aldmeri_lt?: Maybe<String>;
  aldmeri_lte?: Maybe<String>;
  aldmeri_gt?: Maybe<String>;
  aldmeri_gte?: Maybe<String>;
  aldmeri_contains?: Maybe<String>;
  aldmeri_not_contains?: Maybe<String>;
  aldmeri_starts_with?: Maybe<String>;
  aldmeri_not_starts_with?: Maybe<String>;
  aldmeri_ends_with?: Maybe<String>;
  aldmeri_not_ends_with?: Maybe<String>;
  daggerfall?: Maybe<String>;
  daggerfall_not?: Maybe<String>;
  daggerfall_in?: Maybe<String[] | String>;
  daggerfall_not_in?: Maybe<String[] | String>;
  daggerfall_lt?: Maybe<String>;
  daggerfall_lte?: Maybe<String>;
  daggerfall_gt?: Maybe<String>;
  daggerfall_gte?: Maybe<String>;
  daggerfall_contains?: Maybe<String>;
  daggerfall_not_contains?: Maybe<String>;
  daggerfall_starts_with?: Maybe<String>;
  daggerfall_not_starts_with?: Maybe<String>;
  daggerfall_ends_with?: Maybe<String>;
  daggerfall_not_ends_with?: Maybe<String>;
  ebonheart?: Maybe<String>;
  ebonheart_not?: Maybe<String>;
  ebonheart_in?: Maybe<String[] | String>;
  ebonheart_not_in?: Maybe<String[] | String>;
  ebonheart_lt?: Maybe<String>;
  ebonheart_lte?: Maybe<String>;
  ebonheart_gt?: Maybe<String>;
  ebonheart_gte?: Maybe<String>;
  ebonheart_contains?: Maybe<String>;
  ebonheart_not_contains?: Maybe<String>;
  ebonheart_starts_with?: Maybe<String>;
  ebonheart_not_starts_with?: Maybe<String>;
  ebonheart_ends_with?: Maybe<String>;
  ebonheart_not_ends_with?: Maybe<String>;
  AND?: Maybe<LocationWhereInput[] | LocationWhereInput>;
  OR?: Maybe<LocationWhereInput[] | LocationWhereInput>;
  NOT?: Maybe<LocationWhereInput[] | LocationWhereInput>;
}

export interface SpecialBuffWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  buffDescription?: Maybe<String>;
  buffDescription_not?: Maybe<String>;
  buffDescription_in?: Maybe<String[] | String>;
  buffDescription_not_in?: Maybe<String[] | String>;
  buffDescription_lt?: Maybe<String>;
  buffDescription_lte?: Maybe<String>;
  buffDescription_gt?: Maybe<String>;
  buffDescription_gte?: Maybe<String>;
  buffDescription_contains?: Maybe<String>;
  buffDescription_not_contains?: Maybe<String>;
  buffDescription_starts_with?: Maybe<String>;
  buffDescription_not_starts_with?: Maybe<String>;
  buffDescription_ends_with?: Maybe<String>;
  buffDescription_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  duration?: Maybe<Int>;
  duration_not?: Maybe<Int>;
  duration_in?: Maybe<Int[] | Int>;
  duration_not_in?: Maybe<Int[] | Int>;
  duration_lt?: Maybe<Int>;
  duration_lte?: Maybe<Int>;
  duration_gt?: Maybe<Int>;
  duration_gte?: Maybe<Int>;
  notes?: Maybe<String>;
  notes_not?: Maybe<String>;
  notes_in?: Maybe<String[] | String>;
  notes_not_in?: Maybe<String[] | String>;
  notes_lt?: Maybe<String>;
  notes_lte?: Maybe<String>;
  notes_gt?: Maybe<String>;
  notes_gte?: Maybe<String>;
  notes_contains?: Maybe<String>;
  notes_not_contains?: Maybe<String>;
  notes_starts_with?: Maybe<String>;
  notes_not_starts_with?: Maybe<String>;
  notes_ends_with?: Maybe<String>;
  notes_not_ends_with?: Maybe<String>;
  icon?: Maybe<String>;
  icon_not?: Maybe<String>;
  icon_in?: Maybe<String[] | String>;
  icon_not_in?: Maybe<String[] | String>;
  icon_lt?: Maybe<String>;
  icon_lte?: Maybe<String>;
  icon_gt?: Maybe<String>;
  icon_gte?: Maybe<String>;
  icon_contains?: Maybe<String>;
  icon_not_contains?: Maybe<String>;
  icon_starts_with?: Maybe<String>;
  icon_not_starts_with?: Maybe<String>;
  icon_ends_with?: Maybe<String>;
  icon_not_ends_with?: Maybe<String>;
  type?: Maybe<String>;
  type_not?: Maybe<String>;
  type_in?: Maybe<String[] | String>;
  type_not_in?: Maybe<String[] | String>;
  type_lt?: Maybe<String>;
  type_lte?: Maybe<String>;
  type_gt?: Maybe<String>;
  type_gte?: Maybe<String>;
  type_contains?: Maybe<String>;
  type_not_contains?: Maybe<String>;
  type_starts_with?: Maybe<String>;
  type_not_starts_with?: Maybe<String>;
  type_ends_with?: Maybe<String>;
  type_not_ends_with?: Maybe<String>;
  quality?: Maybe<Int>;
  quality_not?: Maybe<Int>;
  quality_in?: Maybe<Int[] | Int>;
  quality_not_in?: Maybe<Int[] | Int>;
  quality_lt?: Maybe<Int>;
  quality_lte?: Maybe<Int>;
  quality_gt?: Maybe<Int>;
  quality_gte?: Maybe<Int>;
  AND?: Maybe<SpecialBuffWhereInput[] | SpecialBuffWhereInput>;
  OR?: Maybe<SpecialBuffWhereInput[] | SpecialBuffWhereInput>;
  NOT?: Maybe<SpecialBuffWhereInput[] | SpecialBuffWhereInput>;
}

export type LocationWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type ModificationWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type MundusWhereUniqueInput = AtLeastOne<{
  id: Maybe<Int>;
}>;

export type PostWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface PostWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  published?: Maybe<Boolean>;
  published_not?: Maybe<Boolean>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  content?: Maybe<String>;
  content_not?: Maybe<String>;
  content_in?: Maybe<String[] | String>;
  content_not_in?: Maybe<String[] | String>;
  content_lt?: Maybe<String>;
  content_lte?: Maybe<String>;
  content_gt?: Maybe<String>;
  content_gte?: Maybe<String>;
  content_contains?: Maybe<String>;
  content_not_contains?: Maybe<String>;
  content_starts_with?: Maybe<String>;
  content_not_starts_with?: Maybe<String>;
  content_ends_with?: Maybe<String>;
  content_not_ends_with?: Maybe<String>;
  author?: Maybe<UserWhereInput>;
  AND?: Maybe<PostWhereInput[] | PostWhereInput>;
  OR?: Maybe<PostWhereInput[] | PostWhereInput>;
  NOT?: Maybe<PostWhereInput[] | PostWhereInput>;
}

export interface UserWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  password?: Maybe<String>;
  password_not?: Maybe<String>;
  password_in?: Maybe<String[] | String>;
  password_not_in?: Maybe<String[] | String>;
  password_lt?: Maybe<String>;
  password_lte?: Maybe<String>;
  password_gt?: Maybe<String>;
  password_gte?: Maybe<String>;
  password_contains?: Maybe<String>;
  password_not_contains?: Maybe<String>;
  password_starts_with?: Maybe<String>;
  password_not_starts_with?: Maybe<String>;
  password_ends_with?: Maybe<String>;
  password_not_ends_with?: Maybe<String>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  posts_every?: Maybe<PostWhereInput>;
  posts_some?: Maybe<PostWhereInput>;
  posts_none?: Maybe<PostWhereInput>;
  AND?: Maybe<UserWhereInput[] | UserWhereInput>;
  OR?: Maybe<UserWhereInput[] | UserWhereInput>;
  NOT?: Maybe<UserWhereInput[] | UserWhereInput>;
}

export type SetWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type SetSelectionWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type SkillWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type SkillSelectionWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type SpecialBuffWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type UserWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  email?: Maybe<String>;
}>;

export interface BuildCreateInput {
  id?: Maybe<ID_Input>;
  name?: Maybe<String>;
  race?: Maybe<String>;
  class?: Maybe<String>;
  bigPieceSelection?: Maybe<SetSelectionCreateManyInput>;
  smallPieceSelection?: Maybe<SetSelectionCreateManyInput>;
  jewelrySelection?: Maybe<SetSelectionCreateManyInput>;
  frontbarSelection?: Maybe<SetSelectionCreateManyInput>;
  backbarSelection?: Maybe<SetSelectionCreateManyInput>;
  newBarOne?: Maybe<SkillSelectionCreateManyInput>;
  newBarTwo?: Maybe<SkillSelectionCreateManyInput>;
  ultimateOne?: Maybe<SkillCreateOneInput>;
  ultimateTwo?: Maybe<SkillCreateOneInput>;
  mundus?: Maybe<MundusCreateOneInput>;
  buff?: Maybe<SpecialBuffCreateOneInput>;
}

export interface SetSelectionCreateManyInput {
  create?: Maybe<SetSelectionCreateInput[] | SetSelectionCreateInput>;
  connect?: Maybe<
    SetSelectionWhereUniqueInput[] | SetSelectionWhereUniqueInput
  >;
}

export interface SetSelectionCreateInput {
  id?: Maybe<ID_Input>;
  icon?: Maybe<String>;
  slot?: Maybe<String>;
  selectedSet?: Maybe<SetCreateOneInput>;
  trait?: Maybe<ModificationCreateOneInput>;
  glyph?: Maybe<ModificationCreateOneInput>;
}

export interface SetCreateOneInput {
  create?: Maybe<SetCreateInput>;
  connect?: Maybe<SetWhereUniqueInput>;
}

export interface SetCreateInput {
  id?: Maybe<ID_Input>;
  setId: Int;
  name: String;
  location: String;
  type: String;
  slug: String;
  bonus_item_1?: Maybe<String>;
  bonus_item_2?: Maybe<String>;
  bonus_item_3?: Maybe<String>;
  bonus_item_4?: Maybe<String>;
  bonus_item_5?: Maybe<String>;
  has_jewels: Int;
  has_weapons: Int;
  has_heavy_armor: Int;
  has_light_armor: Int;
  has_medium_armor: Int;
  traits_needed?: Maybe<Int>;
  pts?: Maybe<Int>;
  eso_id?: Maybe<Int>;
}

export interface ModificationCreateOneInput {
  create?: Maybe<ModificationCreateInput>;
  connect?: Maybe<ModificationWhereUniqueInput>;
}

export interface ModificationCreateInput {
  id?: Maybe<ID_Input>;
  type: String;
  description: String;
  icon?: Maybe<String>;
}

export interface SkillSelectionCreateManyInput {
  create?: Maybe<SkillSelectionCreateInput[] | SkillSelectionCreateInput>;
  connect?: Maybe<
    SkillSelectionWhereUniqueInput[] | SkillSelectionWhereUniqueInput
  >;
}

export interface SkillSelectionCreateInput {
  id?: Maybe<ID_Input>;
  index: Int;
  skill?: Maybe<SkillCreateOneInput>;
}

export interface SkillCreateOneInput {
  create?: Maybe<SkillCreateInput>;
  connect?: Maybe<SkillWhereUniqueInput>;
}

export interface SkillCreateInput {
  id?: Maybe<ID_Input>;
  skillId: Int;
  cast_time: String;
  cost: String;
  effect_1: String;
  effect_2?: Maybe<String>;
  icon?: Maybe<String>;
  name: String;
  parent?: Maybe<Int>;
  pts?: Maybe<Int>;
  range?: Maybe<String>;
  skillline: Int;
  slug: String;
  target?: Maybe<String>;
  type: Int;
  unlocks_at?: Maybe<Int>;
}

export interface MundusCreateOneInput {
  create?: Maybe<MundusCreateInput>;
  connect?: Maybe<MundusWhereUniqueInput>;
}

export interface MundusCreateInput {
  name: String;
  location?: Maybe<LocationCreateOneInput>;
  effect: String;
  value: String;
  icon?: Maybe<String>;
  id?: Maybe<Int>;
}

export interface LocationCreateOneInput {
  create?: Maybe<LocationCreateInput>;
  connect?: Maybe<LocationWhereUniqueInput>;
}

export interface LocationCreateInput {
  id?: Maybe<ID_Input>;
  aldmeri?: Maybe<String>;
  daggerfall?: Maybe<String>;
  ebonheart?: Maybe<String>;
}

export interface SpecialBuffCreateOneInput {
  create?: Maybe<SpecialBuffCreateInput>;
  connect?: Maybe<SpecialBuffWhereUniqueInput>;
}

export interface SpecialBuffCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  buffDescription: String;
  description?: Maybe<String>;
  duration: Int;
  notes?: Maybe<String>;
  icon?: Maybe<String>;
  type?: Maybe<String>;
  quality: Int;
}

export interface BuildUpdateInput {
  name?: Maybe<String>;
  race?: Maybe<String>;
  class?: Maybe<String>;
  bigPieceSelection?: Maybe<SetSelectionUpdateManyInput>;
  smallPieceSelection?: Maybe<SetSelectionUpdateManyInput>;
  jewelrySelection?: Maybe<SetSelectionUpdateManyInput>;
  frontbarSelection?: Maybe<SetSelectionUpdateManyInput>;
  backbarSelection?: Maybe<SetSelectionUpdateManyInput>;
  newBarOne?: Maybe<SkillSelectionUpdateManyInput>;
  newBarTwo?: Maybe<SkillSelectionUpdateManyInput>;
  ultimateOne?: Maybe<SkillUpdateOneInput>;
  ultimateTwo?: Maybe<SkillUpdateOneInput>;
  mundus?: Maybe<MundusUpdateOneInput>;
  buff?: Maybe<SpecialBuffUpdateOneInput>;
}

export interface SetSelectionUpdateManyInput {
  create?: Maybe<SetSelectionCreateInput[] | SetSelectionCreateInput>;
  update?: Maybe<
    | SetSelectionUpdateWithWhereUniqueNestedInput[]
    | SetSelectionUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | SetSelectionUpsertWithWhereUniqueNestedInput[]
    | SetSelectionUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<SetSelectionWhereUniqueInput[] | SetSelectionWhereUniqueInput>;
  connect?: Maybe<
    SetSelectionWhereUniqueInput[] | SetSelectionWhereUniqueInput
  >;
  set?: Maybe<SetSelectionWhereUniqueInput[] | SetSelectionWhereUniqueInput>;
  disconnect?: Maybe<
    SetSelectionWhereUniqueInput[] | SetSelectionWhereUniqueInput
  >;
  deleteMany?: Maybe<
    SetSelectionScalarWhereInput[] | SetSelectionScalarWhereInput
  >;
  updateMany?: Maybe<
    | SetSelectionUpdateManyWithWhereNestedInput[]
    | SetSelectionUpdateManyWithWhereNestedInput
  >;
}

export interface SetSelectionUpdateWithWhereUniqueNestedInput {
  where: SetSelectionWhereUniqueInput;
  data: SetSelectionUpdateDataInput;
}

export interface SetSelectionUpdateDataInput {
  icon?: Maybe<String>;
  slot?: Maybe<String>;
  selectedSet?: Maybe<SetUpdateOneInput>;
  trait?: Maybe<ModificationUpdateOneInput>;
  glyph?: Maybe<ModificationUpdateOneInput>;
}

export interface SetUpdateOneInput {
  create?: Maybe<SetCreateInput>;
  update?: Maybe<SetUpdateDataInput>;
  upsert?: Maybe<SetUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<SetWhereUniqueInput>;
}

export interface SetUpdateDataInput {
  setId?: Maybe<Int>;
  name?: Maybe<String>;
  location?: Maybe<String>;
  type?: Maybe<String>;
  slug?: Maybe<String>;
  bonus_item_1?: Maybe<String>;
  bonus_item_2?: Maybe<String>;
  bonus_item_3?: Maybe<String>;
  bonus_item_4?: Maybe<String>;
  bonus_item_5?: Maybe<String>;
  has_jewels?: Maybe<Int>;
  has_weapons?: Maybe<Int>;
  has_heavy_armor?: Maybe<Int>;
  has_light_armor?: Maybe<Int>;
  has_medium_armor?: Maybe<Int>;
  traits_needed?: Maybe<Int>;
  pts?: Maybe<Int>;
  eso_id?: Maybe<Int>;
}

export interface SetUpsertNestedInput {
  update: SetUpdateDataInput;
  create: SetCreateInput;
}

export interface ModificationUpdateOneInput {
  create?: Maybe<ModificationCreateInput>;
  update?: Maybe<ModificationUpdateDataInput>;
  upsert?: Maybe<ModificationUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<ModificationWhereUniqueInput>;
}

export interface ModificationUpdateDataInput {
  type?: Maybe<String>;
  description?: Maybe<String>;
  icon?: Maybe<String>;
}

export interface ModificationUpsertNestedInput {
  update: ModificationUpdateDataInput;
  create: ModificationCreateInput;
}

export interface SetSelectionUpsertWithWhereUniqueNestedInput {
  where: SetSelectionWhereUniqueInput;
  update: SetSelectionUpdateDataInput;
  create: SetSelectionCreateInput;
}

export interface SetSelectionScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  icon?: Maybe<String>;
  icon_not?: Maybe<String>;
  icon_in?: Maybe<String[] | String>;
  icon_not_in?: Maybe<String[] | String>;
  icon_lt?: Maybe<String>;
  icon_lte?: Maybe<String>;
  icon_gt?: Maybe<String>;
  icon_gte?: Maybe<String>;
  icon_contains?: Maybe<String>;
  icon_not_contains?: Maybe<String>;
  icon_starts_with?: Maybe<String>;
  icon_not_starts_with?: Maybe<String>;
  icon_ends_with?: Maybe<String>;
  icon_not_ends_with?: Maybe<String>;
  slot?: Maybe<String>;
  slot_not?: Maybe<String>;
  slot_in?: Maybe<String[] | String>;
  slot_not_in?: Maybe<String[] | String>;
  slot_lt?: Maybe<String>;
  slot_lte?: Maybe<String>;
  slot_gt?: Maybe<String>;
  slot_gte?: Maybe<String>;
  slot_contains?: Maybe<String>;
  slot_not_contains?: Maybe<String>;
  slot_starts_with?: Maybe<String>;
  slot_not_starts_with?: Maybe<String>;
  slot_ends_with?: Maybe<String>;
  slot_not_ends_with?: Maybe<String>;
  AND?: Maybe<SetSelectionScalarWhereInput[] | SetSelectionScalarWhereInput>;
  OR?: Maybe<SetSelectionScalarWhereInput[] | SetSelectionScalarWhereInput>;
  NOT?: Maybe<SetSelectionScalarWhereInput[] | SetSelectionScalarWhereInput>;
}

export interface SetSelectionUpdateManyWithWhereNestedInput {
  where: SetSelectionScalarWhereInput;
  data: SetSelectionUpdateManyDataInput;
}

export interface SetSelectionUpdateManyDataInput {
  icon?: Maybe<String>;
  slot?: Maybe<String>;
}

export interface SkillSelectionUpdateManyInput {
  create?: Maybe<SkillSelectionCreateInput[] | SkillSelectionCreateInput>;
  update?: Maybe<
    | SkillSelectionUpdateWithWhereUniqueNestedInput[]
    | SkillSelectionUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | SkillSelectionUpsertWithWhereUniqueNestedInput[]
    | SkillSelectionUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<
    SkillSelectionWhereUniqueInput[] | SkillSelectionWhereUniqueInput
  >;
  connect?: Maybe<
    SkillSelectionWhereUniqueInput[] | SkillSelectionWhereUniqueInput
  >;
  set?: Maybe<
    SkillSelectionWhereUniqueInput[] | SkillSelectionWhereUniqueInput
  >;
  disconnect?: Maybe<
    SkillSelectionWhereUniqueInput[] | SkillSelectionWhereUniqueInput
  >;
  deleteMany?: Maybe<
    SkillSelectionScalarWhereInput[] | SkillSelectionScalarWhereInput
  >;
  updateMany?: Maybe<
    | SkillSelectionUpdateManyWithWhereNestedInput[]
    | SkillSelectionUpdateManyWithWhereNestedInput
  >;
}

export interface SkillSelectionUpdateWithWhereUniqueNestedInput {
  where: SkillSelectionWhereUniqueInput;
  data: SkillSelectionUpdateDataInput;
}

export interface SkillSelectionUpdateDataInput {
  index?: Maybe<Int>;
  skill?: Maybe<SkillUpdateOneInput>;
}

export interface SkillUpdateOneInput {
  create?: Maybe<SkillCreateInput>;
  update?: Maybe<SkillUpdateDataInput>;
  upsert?: Maybe<SkillUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<SkillWhereUniqueInput>;
}

export interface SkillUpdateDataInput {
  skillId?: Maybe<Int>;
  cast_time?: Maybe<String>;
  cost?: Maybe<String>;
  effect_1?: Maybe<String>;
  effect_2?: Maybe<String>;
  icon?: Maybe<String>;
  name?: Maybe<String>;
  parent?: Maybe<Int>;
  pts?: Maybe<Int>;
  range?: Maybe<String>;
  skillline?: Maybe<Int>;
  slug?: Maybe<String>;
  target?: Maybe<String>;
  type?: Maybe<Int>;
  unlocks_at?: Maybe<Int>;
}

export interface SkillUpsertNestedInput {
  update: SkillUpdateDataInput;
  create: SkillCreateInput;
}

export interface SkillSelectionUpsertWithWhereUniqueNestedInput {
  where: SkillSelectionWhereUniqueInput;
  update: SkillSelectionUpdateDataInput;
  create: SkillSelectionCreateInput;
}

export interface SkillSelectionScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  index?: Maybe<Int>;
  index_not?: Maybe<Int>;
  index_in?: Maybe<Int[] | Int>;
  index_not_in?: Maybe<Int[] | Int>;
  index_lt?: Maybe<Int>;
  index_lte?: Maybe<Int>;
  index_gt?: Maybe<Int>;
  index_gte?: Maybe<Int>;
  AND?: Maybe<
    SkillSelectionScalarWhereInput[] | SkillSelectionScalarWhereInput
  >;
  OR?: Maybe<SkillSelectionScalarWhereInput[] | SkillSelectionScalarWhereInput>;
  NOT?: Maybe<
    SkillSelectionScalarWhereInput[] | SkillSelectionScalarWhereInput
  >;
}

export interface SkillSelectionUpdateManyWithWhereNestedInput {
  where: SkillSelectionScalarWhereInput;
  data: SkillSelectionUpdateManyDataInput;
}

export interface SkillSelectionUpdateManyDataInput {
  index?: Maybe<Int>;
}

export interface MundusUpdateOneInput {
  create?: Maybe<MundusCreateInput>;
  update?: Maybe<MundusUpdateDataInput>;
  upsert?: Maybe<MundusUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<MundusWhereUniqueInput>;
}

export interface MundusUpdateDataInput {
  name?: Maybe<String>;
  location?: Maybe<LocationUpdateOneInput>;
  effect?: Maybe<String>;
  value?: Maybe<String>;
  icon?: Maybe<String>;
}

export interface LocationUpdateOneInput {
  create?: Maybe<LocationCreateInput>;
  update?: Maybe<LocationUpdateDataInput>;
  upsert?: Maybe<LocationUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<LocationWhereUniqueInput>;
}

export interface LocationUpdateDataInput {
  aldmeri?: Maybe<String>;
  daggerfall?: Maybe<String>;
  ebonheart?: Maybe<String>;
}

export interface LocationUpsertNestedInput {
  update: LocationUpdateDataInput;
  create: LocationCreateInput;
}

export interface MundusUpsertNestedInput {
  update: MundusUpdateDataInput;
  create: MundusCreateInput;
}

export interface SpecialBuffUpdateOneInput {
  create?: Maybe<SpecialBuffCreateInput>;
  update?: Maybe<SpecialBuffUpdateDataInput>;
  upsert?: Maybe<SpecialBuffUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<SpecialBuffWhereUniqueInput>;
}

export interface SpecialBuffUpdateDataInput {
  name?: Maybe<String>;
  buffDescription?: Maybe<String>;
  description?: Maybe<String>;
  duration?: Maybe<Int>;
  notes?: Maybe<String>;
  icon?: Maybe<String>;
  type?: Maybe<String>;
  quality?: Maybe<Int>;
}

export interface SpecialBuffUpsertNestedInput {
  update: SpecialBuffUpdateDataInput;
  create: SpecialBuffCreateInput;
}

export interface BuildUpdateManyMutationInput {
  name?: Maybe<String>;
  race?: Maybe<String>;
  class?: Maybe<String>;
}

export interface LocationUpdateInput {
  aldmeri?: Maybe<String>;
  daggerfall?: Maybe<String>;
  ebonheart?: Maybe<String>;
}

export interface LocationUpdateManyMutationInput {
  aldmeri?: Maybe<String>;
  daggerfall?: Maybe<String>;
  ebonheart?: Maybe<String>;
}

export interface ModificationUpdateInput {
  type?: Maybe<String>;
  description?: Maybe<String>;
  icon?: Maybe<String>;
}

export interface ModificationUpdateManyMutationInput {
  type?: Maybe<String>;
  description?: Maybe<String>;
  icon?: Maybe<String>;
}

export interface MundusUpdateInput {
  name?: Maybe<String>;
  location?: Maybe<LocationUpdateOneInput>;
  effect?: Maybe<String>;
  value?: Maybe<String>;
  icon?: Maybe<String>;
}

export interface MundusUpdateManyMutationInput {
  name?: Maybe<String>;
  effect?: Maybe<String>;
  value?: Maybe<String>;
  icon?: Maybe<String>;
}

export interface PostCreateInput {
  id?: Maybe<ID_Input>;
  published?: Maybe<Boolean>;
  title: String;
  content?: Maybe<String>;
  author: UserCreateOneWithoutPostsInput;
}

export interface UserCreateOneWithoutPostsInput {
  create?: Maybe<UserCreateWithoutPostsInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserCreateWithoutPostsInput {
  id?: Maybe<ID_Input>;
  email: String;
  password: String;
  name?: Maybe<String>;
}

export interface PostUpdateInput {
  published?: Maybe<Boolean>;
  title?: Maybe<String>;
  content?: Maybe<String>;
  author?: Maybe<UserUpdateOneRequiredWithoutPostsInput>;
}

export interface UserUpdateOneRequiredWithoutPostsInput {
  create?: Maybe<UserCreateWithoutPostsInput>;
  update?: Maybe<UserUpdateWithoutPostsDataInput>;
  upsert?: Maybe<UserUpsertWithoutPostsInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserUpdateWithoutPostsDataInput {
  email?: Maybe<String>;
  password?: Maybe<String>;
  name?: Maybe<String>;
}

export interface UserUpsertWithoutPostsInput {
  update: UserUpdateWithoutPostsDataInput;
  create: UserCreateWithoutPostsInput;
}

export interface PostUpdateManyMutationInput {
  published?: Maybe<Boolean>;
  title?: Maybe<String>;
  content?: Maybe<String>;
}

export interface SetUpdateInput {
  setId?: Maybe<Int>;
  name?: Maybe<String>;
  location?: Maybe<String>;
  type?: Maybe<String>;
  slug?: Maybe<String>;
  bonus_item_1?: Maybe<String>;
  bonus_item_2?: Maybe<String>;
  bonus_item_3?: Maybe<String>;
  bonus_item_4?: Maybe<String>;
  bonus_item_5?: Maybe<String>;
  has_jewels?: Maybe<Int>;
  has_weapons?: Maybe<Int>;
  has_heavy_armor?: Maybe<Int>;
  has_light_armor?: Maybe<Int>;
  has_medium_armor?: Maybe<Int>;
  traits_needed?: Maybe<Int>;
  pts?: Maybe<Int>;
  eso_id?: Maybe<Int>;
}

export interface SetUpdateManyMutationInput {
  setId?: Maybe<Int>;
  name?: Maybe<String>;
  location?: Maybe<String>;
  type?: Maybe<String>;
  slug?: Maybe<String>;
  bonus_item_1?: Maybe<String>;
  bonus_item_2?: Maybe<String>;
  bonus_item_3?: Maybe<String>;
  bonus_item_4?: Maybe<String>;
  bonus_item_5?: Maybe<String>;
  has_jewels?: Maybe<Int>;
  has_weapons?: Maybe<Int>;
  has_heavy_armor?: Maybe<Int>;
  has_light_armor?: Maybe<Int>;
  has_medium_armor?: Maybe<Int>;
  traits_needed?: Maybe<Int>;
  pts?: Maybe<Int>;
  eso_id?: Maybe<Int>;
}

export interface SetSelectionUpdateInput {
  icon?: Maybe<String>;
  slot?: Maybe<String>;
  selectedSet?: Maybe<SetUpdateOneInput>;
  trait?: Maybe<ModificationUpdateOneInput>;
  glyph?: Maybe<ModificationUpdateOneInput>;
}

export interface SetSelectionUpdateManyMutationInput {
  icon?: Maybe<String>;
  slot?: Maybe<String>;
}

export interface SkillUpdateInput {
  skillId?: Maybe<Int>;
  cast_time?: Maybe<String>;
  cost?: Maybe<String>;
  effect_1?: Maybe<String>;
  effect_2?: Maybe<String>;
  icon?: Maybe<String>;
  name?: Maybe<String>;
  parent?: Maybe<Int>;
  pts?: Maybe<Int>;
  range?: Maybe<String>;
  skillline?: Maybe<Int>;
  slug?: Maybe<String>;
  target?: Maybe<String>;
  type?: Maybe<Int>;
  unlocks_at?: Maybe<Int>;
}

export interface SkillUpdateManyMutationInput {
  skillId?: Maybe<Int>;
  cast_time?: Maybe<String>;
  cost?: Maybe<String>;
  effect_1?: Maybe<String>;
  effect_2?: Maybe<String>;
  icon?: Maybe<String>;
  name?: Maybe<String>;
  parent?: Maybe<Int>;
  pts?: Maybe<Int>;
  range?: Maybe<String>;
  skillline?: Maybe<Int>;
  slug?: Maybe<String>;
  target?: Maybe<String>;
  type?: Maybe<Int>;
  unlocks_at?: Maybe<Int>;
}

export interface SkillSelectionUpdateInput {
  index?: Maybe<Int>;
  skill?: Maybe<SkillUpdateOneInput>;
}

export interface SkillSelectionUpdateManyMutationInput {
  index?: Maybe<Int>;
}

export interface SpecialBuffUpdateInput {
  name?: Maybe<String>;
  buffDescription?: Maybe<String>;
  description?: Maybe<String>;
  duration?: Maybe<Int>;
  notes?: Maybe<String>;
  icon?: Maybe<String>;
  type?: Maybe<String>;
  quality?: Maybe<Int>;
}

export interface SpecialBuffUpdateManyMutationInput {
  name?: Maybe<String>;
  buffDescription?: Maybe<String>;
  description?: Maybe<String>;
  duration?: Maybe<Int>;
  notes?: Maybe<String>;
  icon?: Maybe<String>;
  type?: Maybe<String>;
  quality?: Maybe<Int>;
}

export interface UserCreateInput {
  id?: Maybe<ID_Input>;
  email: String;
  password: String;
  name?: Maybe<String>;
  posts?: Maybe<PostCreateManyWithoutAuthorInput>;
}

export interface PostCreateManyWithoutAuthorInput {
  create?: Maybe<PostCreateWithoutAuthorInput[] | PostCreateWithoutAuthorInput>;
  connect?: Maybe<PostWhereUniqueInput[] | PostWhereUniqueInput>;
}

export interface PostCreateWithoutAuthorInput {
  id?: Maybe<ID_Input>;
  published?: Maybe<Boolean>;
  title: String;
  content?: Maybe<String>;
}

export interface UserUpdateInput {
  email?: Maybe<String>;
  password?: Maybe<String>;
  name?: Maybe<String>;
  posts?: Maybe<PostUpdateManyWithoutAuthorInput>;
}

export interface PostUpdateManyWithoutAuthorInput {
  create?: Maybe<PostCreateWithoutAuthorInput[] | PostCreateWithoutAuthorInput>;
  delete?: Maybe<PostWhereUniqueInput[] | PostWhereUniqueInput>;
  connect?: Maybe<PostWhereUniqueInput[] | PostWhereUniqueInput>;
  set?: Maybe<PostWhereUniqueInput[] | PostWhereUniqueInput>;
  disconnect?: Maybe<PostWhereUniqueInput[] | PostWhereUniqueInput>;
  update?: Maybe<
    | PostUpdateWithWhereUniqueWithoutAuthorInput[]
    | PostUpdateWithWhereUniqueWithoutAuthorInput
  >;
  upsert?: Maybe<
    | PostUpsertWithWhereUniqueWithoutAuthorInput[]
    | PostUpsertWithWhereUniqueWithoutAuthorInput
  >;
  deleteMany?: Maybe<PostScalarWhereInput[] | PostScalarWhereInput>;
  updateMany?: Maybe<
    PostUpdateManyWithWhereNestedInput[] | PostUpdateManyWithWhereNestedInput
  >;
}

export interface PostUpdateWithWhereUniqueWithoutAuthorInput {
  where: PostWhereUniqueInput;
  data: PostUpdateWithoutAuthorDataInput;
}

export interface PostUpdateWithoutAuthorDataInput {
  published?: Maybe<Boolean>;
  title?: Maybe<String>;
  content?: Maybe<String>;
}

export interface PostUpsertWithWhereUniqueWithoutAuthorInput {
  where: PostWhereUniqueInput;
  update: PostUpdateWithoutAuthorDataInput;
  create: PostCreateWithoutAuthorInput;
}

export interface PostScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  published?: Maybe<Boolean>;
  published_not?: Maybe<Boolean>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  content?: Maybe<String>;
  content_not?: Maybe<String>;
  content_in?: Maybe<String[] | String>;
  content_not_in?: Maybe<String[] | String>;
  content_lt?: Maybe<String>;
  content_lte?: Maybe<String>;
  content_gt?: Maybe<String>;
  content_gte?: Maybe<String>;
  content_contains?: Maybe<String>;
  content_not_contains?: Maybe<String>;
  content_starts_with?: Maybe<String>;
  content_not_starts_with?: Maybe<String>;
  content_ends_with?: Maybe<String>;
  content_not_ends_with?: Maybe<String>;
  AND?: Maybe<PostScalarWhereInput[] | PostScalarWhereInput>;
  OR?: Maybe<PostScalarWhereInput[] | PostScalarWhereInput>;
  NOT?: Maybe<PostScalarWhereInput[] | PostScalarWhereInput>;
}

export interface PostUpdateManyWithWhereNestedInput {
  where: PostScalarWhereInput;
  data: PostUpdateManyDataInput;
}

export interface PostUpdateManyDataInput {
  published?: Maybe<Boolean>;
  title?: Maybe<String>;
  content?: Maybe<String>;
}

export interface UserUpdateManyMutationInput {
  email?: Maybe<String>;
  password?: Maybe<String>;
  name?: Maybe<String>;
}

export interface BuildSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<BuildWhereInput>;
  AND?: Maybe<BuildSubscriptionWhereInput[] | BuildSubscriptionWhereInput>;
  OR?: Maybe<BuildSubscriptionWhereInput[] | BuildSubscriptionWhereInput>;
  NOT?: Maybe<BuildSubscriptionWhereInput[] | BuildSubscriptionWhereInput>;
}

export interface LocationSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<LocationWhereInput>;
  AND?: Maybe<
    LocationSubscriptionWhereInput[] | LocationSubscriptionWhereInput
  >;
  OR?: Maybe<LocationSubscriptionWhereInput[] | LocationSubscriptionWhereInput>;
  NOT?: Maybe<
    LocationSubscriptionWhereInput[] | LocationSubscriptionWhereInput
  >;
}

export interface ModificationSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ModificationWhereInput>;
  AND?: Maybe<
    ModificationSubscriptionWhereInput[] | ModificationSubscriptionWhereInput
  >;
  OR?: Maybe<
    ModificationSubscriptionWhereInput[] | ModificationSubscriptionWhereInput
  >;
  NOT?: Maybe<
    ModificationSubscriptionWhereInput[] | ModificationSubscriptionWhereInput
  >;
}

export interface MundusSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<MundusWhereInput>;
  AND?: Maybe<MundusSubscriptionWhereInput[] | MundusSubscriptionWhereInput>;
  OR?: Maybe<MundusSubscriptionWhereInput[] | MundusSubscriptionWhereInput>;
  NOT?: Maybe<MundusSubscriptionWhereInput[] | MundusSubscriptionWhereInput>;
}

export interface PostSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<PostWhereInput>;
  AND?: Maybe<PostSubscriptionWhereInput[] | PostSubscriptionWhereInput>;
  OR?: Maybe<PostSubscriptionWhereInput[] | PostSubscriptionWhereInput>;
  NOT?: Maybe<PostSubscriptionWhereInput[] | PostSubscriptionWhereInput>;
}

export interface SetSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<SetWhereInput>;
  AND?: Maybe<SetSubscriptionWhereInput[] | SetSubscriptionWhereInput>;
  OR?: Maybe<SetSubscriptionWhereInput[] | SetSubscriptionWhereInput>;
  NOT?: Maybe<SetSubscriptionWhereInput[] | SetSubscriptionWhereInput>;
}

export interface SetSelectionSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<SetSelectionWhereInput>;
  AND?: Maybe<
    SetSelectionSubscriptionWhereInput[] | SetSelectionSubscriptionWhereInput
  >;
  OR?: Maybe<
    SetSelectionSubscriptionWhereInput[] | SetSelectionSubscriptionWhereInput
  >;
  NOT?: Maybe<
    SetSelectionSubscriptionWhereInput[] | SetSelectionSubscriptionWhereInput
  >;
}

export interface SkillSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<SkillWhereInput>;
  AND?: Maybe<SkillSubscriptionWhereInput[] | SkillSubscriptionWhereInput>;
  OR?: Maybe<SkillSubscriptionWhereInput[] | SkillSubscriptionWhereInput>;
  NOT?: Maybe<SkillSubscriptionWhereInput[] | SkillSubscriptionWhereInput>;
}

export interface SkillSelectionSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<SkillSelectionWhereInput>;
  AND?: Maybe<
    | SkillSelectionSubscriptionWhereInput[]
    | SkillSelectionSubscriptionWhereInput
  >;
  OR?: Maybe<
    | SkillSelectionSubscriptionWhereInput[]
    | SkillSelectionSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | SkillSelectionSubscriptionWhereInput[]
    | SkillSelectionSubscriptionWhereInput
  >;
}

export interface SpecialBuffSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<SpecialBuffWhereInput>;
  AND?: Maybe<
    SpecialBuffSubscriptionWhereInput[] | SpecialBuffSubscriptionWhereInput
  >;
  OR?: Maybe<
    SpecialBuffSubscriptionWhereInput[] | SpecialBuffSubscriptionWhereInput
  >;
  NOT?: Maybe<
    SpecialBuffSubscriptionWhereInput[] | SpecialBuffSubscriptionWhereInput
  >;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<UserWhereInput>;
  AND?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  OR?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  NOT?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
}

export interface NodeNode {
  id: ID_Output;
}

export interface Build {
  id: ID_Output;
  name?: String;
  race?: String;
  class?: String;
}

export interface BuildPromise extends Promise<Build>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  race: () => Promise<String>;
  class: () => Promise<String>;
  bigPieceSelection: <T = FragmentableArray<SetSelection>>(args?: {
    where?: SetSelectionWhereInput;
    orderBy?: SetSelectionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  smallPieceSelection: <T = FragmentableArray<SetSelection>>(args?: {
    where?: SetSelectionWhereInput;
    orderBy?: SetSelectionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  jewelrySelection: <T = FragmentableArray<SetSelection>>(args?: {
    where?: SetSelectionWhereInput;
    orderBy?: SetSelectionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  frontbarSelection: <T = FragmentableArray<SetSelection>>(args?: {
    where?: SetSelectionWhereInput;
    orderBy?: SetSelectionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  backbarSelection: <T = FragmentableArray<SetSelection>>(args?: {
    where?: SetSelectionWhereInput;
    orderBy?: SetSelectionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  newBarOne: <T = FragmentableArray<SkillSelection>>(args?: {
    where?: SkillSelectionWhereInput;
    orderBy?: SkillSelectionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  newBarTwo: <T = FragmentableArray<SkillSelection>>(args?: {
    where?: SkillSelectionWhereInput;
    orderBy?: SkillSelectionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  ultimateOne: <T = SkillPromise>() => T;
  ultimateTwo: <T = SkillPromise>() => T;
  mundus: <T = MundusPromise>() => T;
  buff: <T = SpecialBuffPromise>() => T;
}

export interface BuildSubscription
  extends Promise<AsyncIterator<Build>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  race: () => Promise<AsyncIterator<String>>;
  class: () => Promise<AsyncIterator<String>>;
  bigPieceSelection: <
    T = Promise<AsyncIterator<SetSelectionSubscription>>
  >(args?: {
    where?: SetSelectionWhereInput;
    orderBy?: SetSelectionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  smallPieceSelection: <
    T = Promise<AsyncIterator<SetSelectionSubscription>>
  >(args?: {
    where?: SetSelectionWhereInput;
    orderBy?: SetSelectionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  jewelrySelection: <
    T = Promise<AsyncIterator<SetSelectionSubscription>>
  >(args?: {
    where?: SetSelectionWhereInput;
    orderBy?: SetSelectionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  frontbarSelection: <
    T = Promise<AsyncIterator<SetSelectionSubscription>>
  >(args?: {
    where?: SetSelectionWhereInput;
    orderBy?: SetSelectionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  backbarSelection: <
    T = Promise<AsyncIterator<SetSelectionSubscription>>
  >(args?: {
    where?: SetSelectionWhereInput;
    orderBy?: SetSelectionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  newBarOne: <T = Promise<AsyncIterator<SkillSelectionSubscription>>>(args?: {
    where?: SkillSelectionWhereInput;
    orderBy?: SkillSelectionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  newBarTwo: <T = Promise<AsyncIterator<SkillSelectionSubscription>>>(args?: {
    where?: SkillSelectionWhereInput;
    orderBy?: SkillSelectionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  ultimateOne: <T = SkillSubscription>() => T;
  ultimateTwo: <T = SkillSubscription>() => T;
  mundus: <T = MundusSubscription>() => T;
  buff: <T = SpecialBuffSubscription>() => T;
}

export interface BuildNullablePromise
  extends Promise<Build | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  race: () => Promise<String>;
  class: () => Promise<String>;
  bigPieceSelection: <T = FragmentableArray<SetSelection>>(args?: {
    where?: SetSelectionWhereInput;
    orderBy?: SetSelectionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  smallPieceSelection: <T = FragmentableArray<SetSelection>>(args?: {
    where?: SetSelectionWhereInput;
    orderBy?: SetSelectionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  jewelrySelection: <T = FragmentableArray<SetSelection>>(args?: {
    where?: SetSelectionWhereInput;
    orderBy?: SetSelectionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  frontbarSelection: <T = FragmentableArray<SetSelection>>(args?: {
    where?: SetSelectionWhereInput;
    orderBy?: SetSelectionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  backbarSelection: <T = FragmentableArray<SetSelection>>(args?: {
    where?: SetSelectionWhereInput;
    orderBy?: SetSelectionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  newBarOne: <T = FragmentableArray<SkillSelection>>(args?: {
    where?: SkillSelectionWhereInput;
    orderBy?: SkillSelectionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  newBarTwo: <T = FragmentableArray<SkillSelection>>(args?: {
    where?: SkillSelectionWhereInput;
    orderBy?: SkillSelectionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  ultimateOne: <T = SkillPromise>() => T;
  ultimateTwo: <T = SkillPromise>() => T;
  mundus: <T = MundusPromise>() => T;
  buff: <T = SpecialBuffPromise>() => T;
}

export interface SetSelection {
  id: ID_Output;
  icon?: String;
  slot?: String;
}

export interface SetSelectionPromise
  extends Promise<SetSelection>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  icon: () => Promise<String>;
  slot: () => Promise<String>;
  selectedSet: <T = SetPromise>() => T;
  trait: <T = ModificationPromise>() => T;
  glyph: <T = ModificationPromise>() => T;
}

export interface SetSelectionSubscription
  extends Promise<AsyncIterator<SetSelection>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  icon: () => Promise<AsyncIterator<String>>;
  slot: () => Promise<AsyncIterator<String>>;
  selectedSet: <T = SetSubscription>() => T;
  trait: <T = ModificationSubscription>() => T;
  glyph: <T = ModificationSubscription>() => T;
}

export interface SetSelectionNullablePromise
  extends Promise<SetSelection | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  icon: () => Promise<String>;
  slot: () => Promise<String>;
  selectedSet: <T = SetPromise>() => T;
  trait: <T = ModificationPromise>() => T;
  glyph: <T = ModificationPromise>() => T;
}

export interface Set {
  id: ID_Output;
  setId: Int;
  name: String;
  location: String;
  type: String;
  slug: String;
  bonus_item_1?: String;
  bonus_item_2?: String;
  bonus_item_3?: String;
  bonus_item_4?: String;
  bonus_item_5?: String;
  has_jewels: Int;
  has_weapons: Int;
  has_heavy_armor: Int;
  has_light_armor: Int;
  has_medium_armor: Int;
  traits_needed?: Int;
  pts?: Int;
  eso_id?: Int;
}

export interface SetPromise extends Promise<Set>, Fragmentable {
  id: () => Promise<ID_Output>;
  setId: () => Promise<Int>;
  name: () => Promise<String>;
  location: () => Promise<String>;
  type: () => Promise<String>;
  slug: () => Promise<String>;
  bonus_item_1: () => Promise<String>;
  bonus_item_2: () => Promise<String>;
  bonus_item_3: () => Promise<String>;
  bonus_item_4: () => Promise<String>;
  bonus_item_5: () => Promise<String>;
  has_jewels: () => Promise<Int>;
  has_weapons: () => Promise<Int>;
  has_heavy_armor: () => Promise<Int>;
  has_light_armor: () => Promise<Int>;
  has_medium_armor: () => Promise<Int>;
  traits_needed: () => Promise<Int>;
  pts: () => Promise<Int>;
  eso_id: () => Promise<Int>;
}

export interface SetSubscription
  extends Promise<AsyncIterator<Set>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  setId: () => Promise<AsyncIterator<Int>>;
  name: () => Promise<AsyncIterator<String>>;
  location: () => Promise<AsyncIterator<String>>;
  type: () => Promise<AsyncIterator<String>>;
  slug: () => Promise<AsyncIterator<String>>;
  bonus_item_1: () => Promise<AsyncIterator<String>>;
  bonus_item_2: () => Promise<AsyncIterator<String>>;
  bonus_item_3: () => Promise<AsyncIterator<String>>;
  bonus_item_4: () => Promise<AsyncIterator<String>>;
  bonus_item_5: () => Promise<AsyncIterator<String>>;
  has_jewels: () => Promise<AsyncIterator<Int>>;
  has_weapons: () => Promise<AsyncIterator<Int>>;
  has_heavy_armor: () => Promise<AsyncIterator<Int>>;
  has_light_armor: () => Promise<AsyncIterator<Int>>;
  has_medium_armor: () => Promise<AsyncIterator<Int>>;
  traits_needed: () => Promise<AsyncIterator<Int>>;
  pts: () => Promise<AsyncIterator<Int>>;
  eso_id: () => Promise<AsyncIterator<Int>>;
}

export interface SetNullablePromise extends Promise<Set | null>, Fragmentable {
  id: () => Promise<ID_Output>;
  setId: () => Promise<Int>;
  name: () => Promise<String>;
  location: () => Promise<String>;
  type: () => Promise<String>;
  slug: () => Promise<String>;
  bonus_item_1: () => Promise<String>;
  bonus_item_2: () => Promise<String>;
  bonus_item_3: () => Promise<String>;
  bonus_item_4: () => Promise<String>;
  bonus_item_5: () => Promise<String>;
  has_jewels: () => Promise<Int>;
  has_weapons: () => Promise<Int>;
  has_heavy_armor: () => Promise<Int>;
  has_light_armor: () => Promise<Int>;
  has_medium_armor: () => Promise<Int>;
  traits_needed: () => Promise<Int>;
  pts: () => Promise<Int>;
  eso_id: () => Promise<Int>;
}

export interface Modification {
  id: ID_Output;
  type: String;
  description: String;
  icon?: String;
}

export interface ModificationPromise
  extends Promise<Modification>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  type: () => Promise<String>;
  description: () => Promise<String>;
  icon: () => Promise<String>;
}

export interface ModificationSubscription
  extends Promise<AsyncIterator<Modification>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  type: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  icon: () => Promise<AsyncIterator<String>>;
}

export interface ModificationNullablePromise
  extends Promise<Modification | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  type: () => Promise<String>;
  description: () => Promise<String>;
  icon: () => Promise<String>;
}

export interface SkillSelection {
  id: ID_Output;
  index: Int;
}

export interface SkillSelectionPromise
  extends Promise<SkillSelection>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  index: () => Promise<Int>;
  skill: <T = SkillPromise>() => T;
}

export interface SkillSelectionSubscription
  extends Promise<AsyncIterator<SkillSelection>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  index: () => Promise<AsyncIterator<Int>>;
  skill: <T = SkillSubscription>() => T;
}

export interface SkillSelectionNullablePromise
  extends Promise<SkillSelection | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  index: () => Promise<Int>;
  skill: <T = SkillPromise>() => T;
}

export interface Skill {
  id: ID_Output;
  skillId: Int;
  cast_time: String;
  cost: String;
  effect_1: String;
  effect_2?: String;
  icon?: String;
  name: String;
  parent?: Int;
  pts?: Int;
  range?: String;
  skillline: Int;
  slug: String;
  target?: String;
  type: Int;
  unlocks_at?: Int;
}

export interface SkillPromise extends Promise<Skill>, Fragmentable {
  id: () => Promise<ID_Output>;
  skillId: () => Promise<Int>;
  cast_time: () => Promise<String>;
  cost: () => Promise<String>;
  effect_1: () => Promise<String>;
  effect_2: () => Promise<String>;
  icon: () => Promise<String>;
  name: () => Promise<String>;
  parent: () => Promise<Int>;
  pts: () => Promise<Int>;
  range: () => Promise<String>;
  skillline: () => Promise<Int>;
  slug: () => Promise<String>;
  target: () => Promise<String>;
  type: () => Promise<Int>;
  unlocks_at: () => Promise<Int>;
}

export interface SkillSubscription
  extends Promise<AsyncIterator<Skill>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  skillId: () => Promise<AsyncIterator<Int>>;
  cast_time: () => Promise<AsyncIterator<String>>;
  cost: () => Promise<AsyncIterator<String>>;
  effect_1: () => Promise<AsyncIterator<String>>;
  effect_2: () => Promise<AsyncIterator<String>>;
  icon: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  parent: () => Promise<AsyncIterator<Int>>;
  pts: () => Promise<AsyncIterator<Int>>;
  range: () => Promise<AsyncIterator<String>>;
  skillline: () => Promise<AsyncIterator<Int>>;
  slug: () => Promise<AsyncIterator<String>>;
  target: () => Promise<AsyncIterator<String>>;
  type: () => Promise<AsyncIterator<Int>>;
  unlocks_at: () => Promise<AsyncIterator<Int>>;
}

export interface SkillNullablePromise
  extends Promise<Skill | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  skillId: () => Promise<Int>;
  cast_time: () => Promise<String>;
  cost: () => Promise<String>;
  effect_1: () => Promise<String>;
  effect_2: () => Promise<String>;
  icon: () => Promise<String>;
  name: () => Promise<String>;
  parent: () => Promise<Int>;
  pts: () => Promise<Int>;
  range: () => Promise<String>;
  skillline: () => Promise<Int>;
  slug: () => Promise<String>;
  target: () => Promise<String>;
  type: () => Promise<Int>;
  unlocks_at: () => Promise<Int>;
}

export interface Mundus {
  name: String;
  effect: String;
  value: String;
  icon?: String;
  id: Int;
}

export interface MundusPromise extends Promise<Mundus>, Fragmentable {
  name: () => Promise<String>;
  location: <T = LocationPromise>() => T;
  effect: () => Promise<String>;
  value: () => Promise<String>;
  icon: () => Promise<String>;
  id: () => Promise<Int>;
}

export interface MundusSubscription
  extends Promise<AsyncIterator<Mundus>>,
    Fragmentable {
  name: () => Promise<AsyncIterator<String>>;
  location: <T = LocationSubscription>() => T;
  effect: () => Promise<AsyncIterator<String>>;
  value: () => Promise<AsyncIterator<String>>;
  icon: () => Promise<AsyncIterator<String>>;
  id: () => Promise<AsyncIterator<Int>>;
}

export interface MundusNullablePromise
  extends Promise<Mundus | null>,
    Fragmentable {
  name: () => Promise<String>;
  location: <T = LocationPromise>() => T;
  effect: () => Promise<String>;
  value: () => Promise<String>;
  icon: () => Promise<String>;
  id: () => Promise<Int>;
}

export interface Location {
  id: ID_Output;
  aldmeri?: String;
  daggerfall?: String;
  ebonheart?: String;
}

export interface LocationPromise extends Promise<Location>, Fragmentable {
  id: () => Promise<ID_Output>;
  aldmeri: () => Promise<String>;
  daggerfall: () => Promise<String>;
  ebonheart: () => Promise<String>;
}

export interface LocationSubscription
  extends Promise<AsyncIterator<Location>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  aldmeri: () => Promise<AsyncIterator<String>>;
  daggerfall: () => Promise<AsyncIterator<String>>;
  ebonheart: () => Promise<AsyncIterator<String>>;
}

export interface LocationNullablePromise
  extends Promise<Location | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  aldmeri: () => Promise<String>;
  daggerfall: () => Promise<String>;
  ebonheart: () => Promise<String>;
}

export interface SpecialBuff {
  id: ID_Output;
  name: String;
  buffDescription: String;
  description?: String;
  duration: Int;
  notes?: String;
  icon?: String;
  type?: String;
  quality: Int;
}

export interface SpecialBuffPromise extends Promise<SpecialBuff>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  buffDescription: () => Promise<String>;
  description: () => Promise<String>;
  duration: () => Promise<Int>;
  notes: () => Promise<String>;
  icon: () => Promise<String>;
  type: () => Promise<String>;
  quality: () => Promise<Int>;
}

export interface SpecialBuffSubscription
  extends Promise<AsyncIterator<SpecialBuff>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  buffDescription: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  duration: () => Promise<AsyncIterator<Int>>;
  notes: () => Promise<AsyncIterator<String>>;
  icon: () => Promise<AsyncIterator<String>>;
  type: () => Promise<AsyncIterator<String>>;
  quality: () => Promise<AsyncIterator<Int>>;
}

export interface SpecialBuffNullablePromise
  extends Promise<SpecialBuff | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  buffDescription: () => Promise<String>;
  description: () => Promise<String>;
  duration: () => Promise<Int>;
  notes: () => Promise<String>;
  icon: () => Promise<String>;
  type: () => Promise<String>;
  quality: () => Promise<Int>;
}

export interface BuildConnection {
  pageInfo: PageInfo;
  edges: BuildEdge[];
}

export interface BuildConnectionPromise
  extends Promise<BuildConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<BuildEdge>>() => T;
  aggregate: <T = AggregateBuildPromise>() => T;
}

export interface BuildConnectionSubscription
  extends Promise<AsyncIterator<BuildConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<BuildEdgeSubscription>>>() => T;
  aggregate: <T = AggregateBuildSubscription>() => T;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface BuildEdge {
  node: Build;
  cursor: String;
}

export interface BuildEdgePromise extends Promise<BuildEdge>, Fragmentable {
  node: <T = BuildPromise>() => T;
  cursor: () => Promise<String>;
}

export interface BuildEdgeSubscription
  extends Promise<AsyncIterator<BuildEdge>>,
    Fragmentable {
  node: <T = BuildSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateBuild {
  count: Int;
}

export interface AggregateBuildPromise
  extends Promise<AggregateBuild>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateBuildSubscription
  extends Promise<AsyncIterator<AggregateBuild>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface LocationConnection {
  pageInfo: PageInfo;
  edges: LocationEdge[];
}

export interface LocationConnectionPromise
  extends Promise<LocationConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<LocationEdge>>() => T;
  aggregate: <T = AggregateLocationPromise>() => T;
}

export interface LocationConnectionSubscription
  extends Promise<AsyncIterator<LocationConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<LocationEdgeSubscription>>>() => T;
  aggregate: <T = AggregateLocationSubscription>() => T;
}

export interface LocationEdge {
  node: Location;
  cursor: String;
}

export interface LocationEdgePromise
  extends Promise<LocationEdge>,
    Fragmentable {
  node: <T = LocationPromise>() => T;
  cursor: () => Promise<String>;
}

export interface LocationEdgeSubscription
  extends Promise<AsyncIterator<LocationEdge>>,
    Fragmentable {
  node: <T = LocationSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateLocation {
  count: Int;
}

export interface AggregateLocationPromise
  extends Promise<AggregateLocation>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateLocationSubscription
  extends Promise<AsyncIterator<AggregateLocation>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ModificationConnection {
  pageInfo: PageInfo;
  edges: ModificationEdge[];
}

export interface ModificationConnectionPromise
  extends Promise<ModificationConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ModificationEdge>>() => T;
  aggregate: <T = AggregateModificationPromise>() => T;
}

export interface ModificationConnectionSubscription
  extends Promise<AsyncIterator<ModificationConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ModificationEdgeSubscription>>>() => T;
  aggregate: <T = AggregateModificationSubscription>() => T;
}

export interface ModificationEdge {
  node: Modification;
  cursor: String;
}

export interface ModificationEdgePromise
  extends Promise<ModificationEdge>,
    Fragmentable {
  node: <T = ModificationPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ModificationEdgeSubscription
  extends Promise<AsyncIterator<ModificationEdge>>,
    Fragmentable {
  node: <T = ModificationSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateModification {
  count: Int;
}

export interface AggregateModificationPromise
  extends Promise<AggregateModification>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateModificationSubscription
  extends Promise<AsyncIterator<AggregateModification>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface MundusConnection {
  pageInfo: PageInfo;
  edges: MundusEdge[];
}

export interface MundusConnectionPromise
  extends Promise<MundusConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<MundusEdge>>() => T;
  aggregate: <T = AggregateMundusPromise>() => T;
}

export interface MundusConnectionSubscription
  extends Promise<AsyncIterator<MundusConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<MundusEdgeSubscription>>>() => T;
  aggregate: <T = AggregateMundusSubscription>() => T;
}

export interface MundusEdge {
  node: Mundus;
  cursor: String;
}

export interface MundusEdgePromise extends Promise<MundusEdge>, Fragmentable {
  node: <T = MundusPromise>() => T;
  cursor: () => Promise<String>;
}

export interface MundusEdgeSubscription
  extends Promise<AsyncIterator<MundusEdge>>,
    Fragmentable {
  node: <T = MundusSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateMundus {
  count: Int;
}

export interface AggregateMundusPromise
  extends Promise<AggregateMundus>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateMundusSubscription
  extends Promise<AsyncIterator<AggregateMundus>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Post {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  published: Boolean;
  title: String;
  content?: String;
}

export interface PostPromise extends Promise<Post>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  published: () => Promise<Boolean>;
  title: () => Promise<String>;
  content: () => Promise<String>;
  author: <T = UserPromise>() => T;
}

export interface PostSubscription
  extends Promise<AsyncIterator<Post>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  published: () => Promise<AsyncIterator<Boolean>>;
  title: () => Promise<AsyncIterator<String>>;
  content: () => Promise<AsyncIterator<String>>;
  author: <T = UserSubscription>() => T;
}

export interface PostNullablePromise
  extends Promise<Post | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  published: () => Promise<Boolean>;
  title: () => Promise<String>;
  content: () => Promise<String>;
  author: <T = UserPromise>() => T;
}

export interface User {
  id: ID_Output;
  email: String;
  password: String;
  name?: String;
}

export interface UserPromise extends Promise<User>, Fragmentable {
  id: () => Promise<ID_Output>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  name: () => Promise<String>;
  posts: <T = FragmentableArray<Post>>(args?: {
    where?: PostWhereInput;
    orderBy?: PostOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  email: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  posts: <T = Promise<AsyncIterator<PostSubscription>>>(args?: {
    where?: PostWhereInput;
    orderBy?: PostOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface UserNullablePromise
  extends Promise<User | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  name: () => Promise<String>;
  posts: <T = FragmentableArray<Post>>(args?: {
    where?: PostWhereInput;
    orderBy?: PostOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface PostConnection {
  pageInfo: PageInfo;
  edges: PostEdge[];
}

export interface PostConnectionPromise
  extends Promise<PostConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PostEdge>>() => T;
  aggregate: <T = AggregatePostPromise>() => T;
}

export interface PostConnectionSubscription
  extends Promise<AsyncIterator<PostConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PostEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePostSubscription>() => T;
}

export interface PostEdge {
  node: Post;
  cursor: String;
}

export interface PostEdgePromise extends Promise<PostEdge>, Fragmentable {
  node: <T = PostPromise>() => T;
  cursor: () => Promise<String>;
}

export interface PostEdgeSubscription
  extends Promise<AsyncIterator<PostEdge>>,
    Fragmentable {
  node: <T = PostSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregatePost {
  count: Int;
}

export interface AggregatePostPromise
  extends Promise<AggregatePost>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePostSubscription
  extends Promise<AsyncIterator<AggregatePost>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface SetConnection {
  pageInfo: PageInfo;
  edges: SetEdge[];
}

export interface SetConnectionPromise
  extends Promise<SetConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<SetEdge>>() => T;
  aggregate: <T = AggregateSetPromise>() => T;
}

export interface SetConnectionSubscription
  extends Promise<AsyncIterator<SetConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<SetEdgeSubscription>>>() => T;
  aggregate: <T = AggregateSetSubscription>() => T;
}

export interface SetEdge {
  node: Set;
  cursor: String;
}

export interface SetEdgePromise extends Promise<SetEdge>, Fragmentable {
  node: <T = SetPromise>() => T;
  cursor: () => Promise<String>;
}

export interface SetEdgeSubscription
  extends Promise<AsyncIterator<SetEdge>>,
    Fragmentable {
  node: <T = SetSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateSet {
  count: Int;
}

export interface AggregateSetPromise
  extends Promise<AggregateSet>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateSetSubscription
  extends Promise<AsyncIterator<AggregateSet>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface SetSelectionConnection {
  pageInfo: PageInfo;
  edges: SetSelectionEdge[];
}

export interface SetSelectionConnectionPromise
  extends Promise<SetSelectionConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<SetSelectionEdge>>() => T;
  aggregate: <T = AggregateSetSelectionPromise>() => T;
}

export interface SetSelectionConnectionSubscription
  extends Promise<AsyncIterator<SetSelectionConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<SetSelectionEdgeSubscription>>>() => T;
  aggregate: <T = AggregateSetSelectionSubscription>() => T;
}

export interface SetSelectionEdge {
  node: SetSelection;
  cursor: String;
}

export interface SetSelectionEdgePromise
  extends Promise<SetSelectionEdge>,
    Fragmentable {
  node: <T = SetSelectionPromise>() => T;
  cursor: () => Promise<String>;
}

export interface SetSelectionEdgeSubscription
  extends Promise<AsyncIterator<SetSelectionEdge>>,
    Fragmentable {
  node: <T = SetSelectionSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateSetSelection {
  count: Int;
}

export interface AggregateSetSelectionPromise
  extends Promise<AggregateSetSelection>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateSetSelectionSubscription
  extends Promise<AsyncIterator<AggregateSetSelection>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface SkillConnection {
  pageInfo: PageInfo;
  edges: SkillEdge[];
}

export interface SkillConnectionPromise
  extends Promise<SkillConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<SkillEdge>>() => T;
  aggregate: <T = AggregateSkillPromise>() => T;
}

export interface SkillConnectionSubscription
  extends Promise<AsyncIterator<SkillConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<SkillEdgeSubscription>>>() => T;
  aggregate: <T = AggregateSkillSubscription>() => T;
}

export interface SkillEdge {
  node: Skill;
  cursor: String;
}

export interface SkillEdgePromise extends Promise<SkillEdge>, Fragmentable {
  node: <T = SkillPromise>() => T;
  cursor: () => Promise<String>;
}

export interface SkillEdgeSubscription
  extends Promise<AsyncIterator<SkillEdge>>,
    Fragmentable {
  node: <T = SkillSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateSkill {
  count: Int;
}

export interface AggregateSkillPromise
  extends Promise<AggregateSkill>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateSkillSubscription
  extends Promise<AsyncIterator<AggregateSkill>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface SkillSelectionConnection {
  pageInfo: PageInfo;
  edges: SkillSelectionEdge[];
}

export interface SkillSelectionConnectionPromise
  extends Promise<SkillSelectionConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<SkillSelectionEdge>>() => T;
  aggregate: <T = AggregateSkillSelectionPromise>() => T;
}

export interface SkillSelectionConnectionSubscription
  extends Promise<AsyncIterator<SkillSelectionConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<SkillSelectionEdgeSubscription>>>() => T;
  aggregate: <T = AggregateSkillSelectionSubscription>() => T;
}

export interface SkillSelectionEdge {
  node: SkillSelection;
  cursor: String;
}

export interface SkillSelectionEdgePromise
  extends Promise<SkillSelectionEdge>,
    Fragmentable {
  node: <T = SkillSelectionPromise>() => T;
  cursor: () => Promise<String>;
}

export interface SkillSelectionEdgeSubscription
  extends Promise<AsyncIterator<SkillSelectionEdge>>,
    Fragmentable {
  node: <T = SkillSelectionSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateSkillSelection {
  count: Int;
}

export interface AggregateSkillSelectionPromise
  extends Promise<AggregateSkillSelection>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateSkillSelectionSubscription
  extends Promise<AsyncIterator<AggregateSkillSelection>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface SpecialBuffConnection {
  pageInfo: PageInfo;
  edges: SpecialBuffEdge[];
}

export interface SpecialBuffConnectionPromise
  extends Promise<SpecialBuffConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<SpecialBuffEdge>>() => T;
  aggregate: <T = AggregateSpecialBuffPromise>() => T;
}

export interface SpecialBuffConnectionSubscription
  extends Promise<AsyncIterator<SpecialBuffConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<SpecialBuffEdgeSubscription>>>() => T;
  aggregate: <T = AggregateSpecialBuffSubscription>() => T;
}

export interface SpecialBuffEdge {
  node: SpecialBuff;
  cursor: String;
}

export interface SpecialBuffEdgePromise
  extends Promise<SpecialBuffEdge>,
    Fragmentable {
  node: <T = SpecialBuffPromise>() => T;
  cursor: () => Promise<String>;
}

export interface SpecialBuffEdgeSubscription
  extends Promise<AsyncIterator<SpecialBuffEdge>>,
    Fragmentable {
  node: <T = SpecialBuffSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateSpecialBuff {
  count: Int;
}

export interface AggregateSpecialBuffPromise
  extends Promise<AggregateSpecialBuff>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateSpecialBuffSubscription
  extends Promise<AsyncIterator<AggregateSpecialBuff>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UserConnection {
  pageInfo: PageInfo;
  edges: UserEdge[];
}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUserPromise>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface UserEdge {
  node: User;
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = UserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface BuildSubscriptionPayload {
  mutation: MutationType;
  node: Build;
  updatedFields: String[];
  previousValues: BuildPreviousValues;
}

export interface BuildSubscriptionPayloadPromise
  extends Promise<BuildSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = BuildPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = BuildPreviousValuesPromise>() => T;
}

export interface BuildSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<BuildSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = BuildSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = BuildPreviousValuesSubscription>() => T;
}

export interface BuildPreviousValues {
  id: ID_Output;
  name?: String;
  race?: String;
  class?: String;
}

export interface BuildPreviousValuesPromise
  extends Promise<BuildPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  race: () => Promise<String>;
  class: () => Promise<String>;
}

export interface BuildPreviousValuesSubscription
  extends Promise<AsyncIterator<BuildPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  race: () => Promise<AsyncIterator<String>>;
  class: () => Promise<AsyncIterator<String>>;
}

export interface LocationSubscriptionPayload {
  mutation: MutationType;
  node: Location;
  updatedFields: String[];
  previousValues: LocationPreviousValues;
}

export interface LocationSubscriptionPayloadPromise
  extends Promise<LocationSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = LocationPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = LocationPreviousValuesPromise>() => T;
}

export interface LocationSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<LocationSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = LocationSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = LocationPreviousValuesSubscription>() => T;
}

export interface LocationPreviousValues {
  id: ID_Output;
  aldmeri?: String;
  daggerfall?: String;
  ebonheart?: String;
}

export interface LocationPreviousValuesPromise
  extends Promise<LocationPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  aldmeri: () => Promise<String>;
  daggerfall: () => Promise<String>;
  ebonheart: () => Promise<String>;
}

export interface LocationPreviousValuesSubscription
  extends Promise<AsyncIterator<LocationPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  aldmeri: () => Promise<AsyncIterator<String>>;
  daggerfall: () => Promise<AsyncIterator<String>>;
  ebonheart: () => Promise<AsyncIterator<String>>;
}

export interface ModificationSubscriptionPayload {
  mutation: MutationType;
  node: Modification;
  updatedFields: String[];
  previousValues: ModificationPreviousValues;
}

export interface ModificationSubscriptionPayloadPromise
  extends Promise<ModificationSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ModificationPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ModificationPreviousValuesPromise>() => T;
}

export interface ModificationSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ModificationSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ModificationSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ModificationPreviousValuesSubscription>() => T;
}

export interface ModificationPreviousValues {
  id: ID_Output;
  type: String;
  description: String;
  icon?: String;
}

export interface ModificationPreviousValuesPromise
  extends Promise<ModificationPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  type: () => Promise<String>;
  description: () => Promise<String>;
  icon: () => Promise<String>;
}

export interface ModificationPreviousValuesSubscription
  extends Promise<AsyncIterator<ModificationPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  type: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  icon: () => Promise<AsyncIterator<String>>;
}

export interface MundusSubscriptionPayload {
  mutation: MutationType;
  node: Mundus;
  updatedFields: String[];
  previousValues: MundusPreviousValues;
}

export interface MundusSubscriptionPayloadPromise
  extends Promise<MundusSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = MundusPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = MundusPreviousValuesPromise>() => T;
}

export interface MundusSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<MundusSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = MundusSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = MundusPreviousValuesSubscription>() => T;
}

export interface MundusPreviousValues {
  name: String;
  effect: String;
  value: String;
  icon?: String;
  id: Int;
}

export interface MundusPreviousValuesPromise
  extends Promise<MundusPreviousValues>,
    Fragmentable {
  name: () => Promise<String>;
  effect: () => Promise<String>;
  value: () => Promise<String>;
  icon: () => Promise<String>;
  id: () => Promise<Int>;
}

export interface MundusPreviousValuesSubscription
  extends Promise<AsyncIterator<MundusPreviousValues>>,
    Fragmentable {
  name: () => Promise<AsyncIterator<String>>;
  effect: () => Promise<AsyncIterator<String>>;
  value: () => Promise<AsyncIterator<String>>;
  icon: () => Promise<AsyncIterator<String>>;
  id: () => Promise<AsyncIterator<Int>>;
}

export interface PostSubscriptionPayload {
  mutation: MutationType;
  node: Post;
  updatedFields: String[];
  previousValues: PostPreviousValues;
}

export interface PostSubscriptionPayloadPromise
  extends Promise<PostSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PostPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PostPreviousValuesPromise>() => T;
}

export interface PostSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PostSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PostSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PostPreviousValuesSubscription>() => T;
}

export interface PostPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  published: Boolean;
  title: String;
  content?: String;
}

export interface PostPreviousValuesPromise
  extends Promise<PostPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  published: () => Promise<Boolean>;
  title: () => Promise<String>;
  content: () => Promise<String>;
}

export interface PostPreviousValuesSubscription
  extends Promise<AsyncIterator<PostPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  published: () => Promise<AsyncIterator<Boolean>>;
  title: () => Promise<AsyncIterator<String>>;
  content: () => Promise<AsyncIterator<String>>;
}

export interface SetSubscriptionPayload {
  mutation: MutationType;
  node: Set;
  updatedFields: String[];
  previousValues: SetPreviousValues;
}

export interface SetSubscriptionPayloadPromise
  extends Promise<SetSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SetPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SetPreviousValuesPromise>() => T;
}

export interface SetSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SetSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SetSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SetPreviousValuesSubscription>() => T;
}

export interface SetPreviousValues {
  id: ID_Output;
  setId: Int;
  name: String;
  location: String;
  type: String;
  slug: String;
  bonus_item_1?: String;
  bonus_item_2?: String;
  bonus_item_3?: String;
  bonus_item_4?: String;
  bonus_item_5?: String;
  has_jewels: Int;
  has_weapons: Int;
  has_heavy_armor: Int;
  has_light_armor: Int;
  has_medium_armor: Int;
  traits_needed?: Int;
  pts?: Int;
  eso_id?: Int;
}

export interface SetPreviousValuesPromise
  extends Promise<SetPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  setId: () => Promise<Int>;
  name: () => Promise<String>;
  location: () => Promise<String>;
  type: () => Promise<String>;
  slug: () => Promise<String>;
  bonus_item_1: () => Promise<String>;
  bonus_item_2: () => Promise<String>;
  bonus_item_3: () => Promise<String>;
  bonus_item_4: () => Promise<String>;
  bonus_item_5: () => Promise<String>;
  has_jewels: () => Promise<Int>;
  has_weapons: () => Promise<Int>;
  has_heavy_armor: () => Promise<Int>;
  has_light_armor: () => Promise<Int>;
  has_medium_armor: () => Promise<Int>;
  traits_needed: () => Promise<Int>;
  pts: () => Promise<Int>;
  eso_id: () => Promise<Int>;
}

export interface SetPreviousValuesSubscription
  extends Promise<AsyncIterator<SetPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  setId: () => Promise<AsyncIterator<Int>>;
  name: () => Promise<AsyncIterator<String>>;
  location: () => Promise<AsyncIterator<String>>;
  type: () => Promise<AsyncIterator<String>>;
  slug: () => Promise<AsyncIterator<String>>;
  bonus_item_1: () => Promise<AsyncIterator<String>>;
  bonus_item_2: () => Promise<AsyncIterator<String>>;
  bonus_item_3: () => Promise<AsyncIterator<String>>;
  bonus_item_4: () => Promise<AsyncIterator<String>>;
  bonus_item_5: () => Promise<AsyncIterator<String>>;
  has_jewels: () => Promise<AsyncIterator<Int>>;
  has_weapons: () => Promise<AsyncIterator<Int>>;
  has_heavy_armor: () => Promise<AsyncIterator<Int>>;
  has_light_armor: () => Promise<AsyncIterator<Int>>;
  has_medium_armor: () => Promise<AsyncIterator<Int>>;
  traits_needed: () => Promise<AsyncIterator<Int>>;
  pts: () => Promise<AsyncIterator<Int>>;
  eso_id: () => Promise<AsyncIterator<Int>>;
}

export interface SetSelectionSubscriptionPayload {
  mutation: MutationType;
  node: SetSelection;
  updatedFields: String[];
  previousValues: SetSelectionPreviousValues;
}

export interface SetSelectionSubscriptionPayloadPromise
  extends Promise<SetSelectionSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SetSelectionPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SetSelectionPreviousValuesPromise>() => T;
}

export interface SetSelectionSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SetSelectionSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SetSelectionSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SetSelectionPreviousValuesSubscription>() => T;
}

export interface SetSelectionPreviousValues {
  id: ID_Output;
  icon?: String;
  slot?: String;
}

export interface SetSelectionPreviousValuesPromise
  extends Promise<SetSelectionPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  icon: () => Promise<String>;
  slot: () => Promise<String>;
}

export interface SetSelectionPreviousValuesSubscription
  extends Promise<AsyncIterator<SetSelectionPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  icon: () => Promise<AsyncIterator<String>>;
  slot: () => Promise<AsyncIterator<String>>;
}

export interface SkillSubscriptionPayload {
  mutation: MutationType;
  node: Skill;
  updatedFields: String[];
  previousValues: SkillPreviousValues;
}

export interface SkillSubscriptionPayloadPromise
  extends Promise<SkillSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SkillPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SkillPreviousValuesPromise>() => T;
}

export interface SkillSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SkillSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SkillSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SkillPreviousValuesSubscription>() => T;
}

export interface SkillPreviousValues {
  id: ID_Output;
  skillId: Int;
  cast_time: String;
  cost: String;
  effect_1: String;
  effect_2?: String;
  icon?: String;
  name: String;
  parent?: Int;
  pts?: Int;
  range?: String;
  skillline: Int;
  slug: String;
  target?: String;
  type: Int;
  unlocks_at?: Int;
}

export interface SkillPreviousValuesPromise
  extends Promise<SkillPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  skillId: () => Promise<Int>;
  cast_time: () => Promise<String>;
  cost: () => Promise<String>;
  effect_1: () => Promise<String>;
  effect_2: () => Promise<String>;
  icon: () => Promise<String>;
  name: () => Promise<String>;
  parent: () => Promise<Int>;
  pts: () => Promise<Int>;
  range: () => Promise<String>;
  skillline: () => Promise<Int>;
  slug: () => Promise<String>;
  target: () => Promise<String>;
  type: () => Promise<Int>;
  unlocks_at: () => Promise<Int>;
}

export interface SkillPreviousValuesSubscription
  extends Promise<AsyncIterator<SkillPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  skillId: () => Promise<AsyncIterator<Int>>;
  cast_time: () => Promise<AsyncIterator<String>>;
  cost: () => Promise<AsyncIterator<String>>;
  effect_1: () => Promise<AsyncIterator<String>>;
  effect_2: () => Promise<AsyncIterator<String>>;
  icon: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  parent: () => Promise<AsyncIterator<Int>>;
  pts: () => Promise<AsyncIterator<Int>>;
  range: () => Promise<AsyncIterator<String>>;
  skillline: () => Promise<AsyncIterator<Int>>;
  slug: () => Promise<AsyncIterator<String>>;
  target: () => Promise<AsyncIterator<String>>;
  type: () => Promise<AsyncIterator<Int>>;
  unlocks_at: () => Promise<AsyncIterator<Int>>;
}

export interface SkillSelectionSubscriptionPayload {
  mutation: MutationType;
  node: SkillSelection;
  updatedFields: String[];
  previousValues: SkillSelectionPreviousValues;
}

export interface SkillSelectionSubscriptionPayloadPromise
  extends Promise<SkillSelectionSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SkillSelectionPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SkillSelectionPreviousValuesPromise>() => T;
}

export interface SkillSelectionSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SkillSelectionSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SkillSelectionSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SkillSelectionPreviousValuesSubscription>() => T;
}

export interface SkillSelectionPreviousValues {
  id: ID_Output;
  index: Int;
}

export interface SkillSelectionPreviousValuesPromise
  extends Promise<SkillSelectionPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  index: () => Promise<Int>;
}

export interface SkillSelectionPreviousValuesSubscription
  extends Promise<AsyncIterator<SkillSelectionPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  index: () => Promise<AsyncIterator<Int>>;
}

export interface SpecialBuffSubscriptionPayload {
  mutation: MutationType;
  node: SpecialBuff;
  updatedFields: String[];
  previousValues: SpecialBuffPreviousValues;
}

export interface SpecialBuffSubscriptionPayloadPromise
  extends Promise<SpecialBuffSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SpecialBuffPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SpecialBuffPreviousValuesPromise>() => T;
}

export interface SpecialBuffSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SpecialBuffSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SpecialBuffSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SpecialBuffPreviousValuesSubscription>() => T;
}

export interface SpecialBuffPreviousValues {
  id: ID_Output;
  name: String;
  buffDescription: String;
  description?: String;
  duration: Int;
  notes?: String;
  icon?: String;
  type?: String;
  quality: Int;
}

export interface SpecialBuffPreviousValuesPromise
  extends Promise<SpecialBuffPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  buffDescription: () => Promise<String>;
  description: () => Promise<String>;
  duration: () => Promise<Int>;
  notes: () => Promise<String>;
  icon: () => Promise<String>;
  type: () => Promise<String>;
  quality: () => Promise<Int>;
}

export interface SpecialBuffPreviousValuesSubscription
  extends Promise<AsyncIterator<SpecialBuffPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  buffDescription: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  duration: () => Promise<AsyncIterator<Int>>;
  notes: () => Promise<AsyncIterator<String>>;
  icon: () => Promise<AsyncIterator<String>>;
  type: () => Promise<AsyncIterator<String>>;
  quality: () => Promise<AsyncIterator<Int>>;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  node: User;
  updatedFields: String[];
  previousValues: UserPreviousValues;
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValuesPromise>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface UserPreviousValues {
  id: ID_Output;
  email: String;
  password: String;
  name?: String;
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  name: () => Promise<String>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  email: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
}

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.
*/
export type Int = number;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

export type Long = string;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "Post",
    embedded: false
  },
  {
    name: "User",
    embedded: false
  },
  {
    name: "Location",
    embedded: false
  },
  {
    name: "Mundus",
    embedded: false
  },
  {
    name: "SpecialBuff",
    embedded: false
  },
  {
    name: "SetSelection",
    embedded: false
  },
  {
    name: "Set",
    embedded: false
  },
  {
    name: "Modification",
    embedded: false
  },
  {
    name: "SkillSelection",
    embedded: false
  },
  {
    name: "Skill",
    embedded: false
  },
  {
    name: "Build",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const Prisma = makePrismaClientClass<ClientConstructor<Prisma>>({
  typeDefs,
  models,
  endpoint: `http://localhost:4466`
});
export const prisma = new Prisma();
